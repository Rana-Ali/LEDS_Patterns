
GccApplication3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001078  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002ac  00800060  00001078  0000110c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000452  0080030c  0080030c  000013b8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000013b8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000013e8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00001424  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002774  00000000  00000000  0000165c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ef9  00000000  00000000  00003dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001366  00000000  00000000  00004cc9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004d0  00000000  00000000  00006030  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e43  00000000  00000000  00006500  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001539  00000000  00000000  00007343  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001e8  00000000  00000000  0000887c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 88 04 	jmp	0x910	; 0x910 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	13 e0       	ldi	r17, 0x03	; 3
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e7       	ldi	r30, 0x78	; 120
      68:	f0 e1       	ldi	r31, 0x10	; 16
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 30       	cpi	r26, 0x0C	; 12
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	ac e0       	ldi	r26, 0x0C	; 12
      7a:	b3 e0       	ldi	r27, 0x03	; 3
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 35       	cpi	r26, 0x5E	; 94
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 02 08 	call	0x1004	; 0x1004 <main>
      8a:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_VidSetPinDir>:
	switch (copy_u8Port)
		{
			case PORT_A: *pu8Value=GET_BIT(PINA,copy_u8Pin); break;
			case PORT_B: *pu8Value=GET_BIT(PINB,copy_u8Pin); break;
			case PORT_C: *pu8Value=GET_BIT(PINC,copy_u8Pin); break;
			case PORT_D: *pu8Value=GET_BIT(PIND,copy_u8Pin); break;
      92:	41 30       	cpi	r20, 0x01	; 1
      94:	a1 f5       	brne	.+104    	; 0xfe <DIO_VidSetPinDir+0x6c>
      96:	81 30       	cpi	r24, 0x01	; 1
      98:	89 f0       	breq	.+34     	; 0xbc <DIO_VidSetPinDir+0x2a>
      9a:	28 f0       	brcs	.+10     	; 0xa6 <DIO_VidSetPinDir+0x14>
      9c:	82 30       	cpi	r24, 0x02	; 2
      9e:	c9 f0       	breq	.+50     	; 0xd2 <DIO_VidSetPinDir+0x40>
      a0:	83 30       	cpi	r24, 0x03	; 3
      a2:	11 f1       	breq	.+68     	; 0xe8 <DIO_VidSetPinDir+0x56>
      a4:	08 95       	ret
      a6:	2a b3       	in	r18, 0x1a	; 26
      a8:	81 e0       	ldi	r24, 0x01	; 1
      aa:	90 e0       	ldi	r25, 0x00	; 0
      ac:	02 c0       	rjmp	.+4      	; 0xb2 <DIO_VidSetPinDir+0x20>
      ae:	88 0f       	add	r24, r24
      b0:	99 1f       	adc	r25, r25
      b2:	6a 95       	dec	r22
      b4:	e2 f7       	brpl	.-8      	; 0xae <DIO_VidSetPinDir+0x1c>
      b6:	82 2b       	or	r24, r18
      b8:	8a bb       	out	0x1a, r24	; 26
      ba:	08 95       	ret
      bc:	27 b3       	in	r18, 0x17	; 23
      be:	81 e0       	ldi	r24, 0x01	; 1
      c0:	90 e0       	ldi	r25, 0x00	; 0
      c2:	02 c0       	rjmp	.+4      	; 0xc8 <DIO_VidSetPinDir+0x36>
      c4:	88 0f       	add	r24, r24
      c6:	99 1f       	adc	r25, r25
      c8:	6a 95       	dec	r22
      ca:	e2 f7       	brpl	.-8      	; 0xc4 <DIO_VidSetPinDir+0x32>
      cc:	82 2b       	or	r24, r18
      ce:	87 bb       	out	0x17, r24	; 23
      d0:	08 95       	ret
      d2:	24 b3       	in	r18, 0x14	; 20
      d4:	81 e0       	ldi	r24, 0x01	; 1
      d6:	90 e0       	ldi	r25, 0x00	; 0
      d8:	02 c0       	rjmp	.+4      	; 0xde <DIO_VidSetPinDir+0x4c>
      da:	88 0f       	add	r24, r24
      dc:	99 1f       	adc	r25, r25
      de:	6a 95       	dec	r22
      e0:	e2 f7       	brpl	.-8      	; 0xda <DIO_VidSetPinDir+0x48>
      e2:	82 2b       	or	r24, r18
      e4:	84 bb       	out	0x14, r24	; 20
      e6:	08 95       	ret
      e8:	21 b3       	in	r18, 0x11	; 17
      ea:	81 e0       	ldi	r24, 0x01	; 1
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	02 c0       	rjmp	.+4      	; 0xf4 <DIO_VidSetPinDir+0x62>
      f0:	88 0f       	add	r24, r24
      f2:	99 1f       	adc	r25, r25
      f4:	6a 95       	dec	r22
      f6:	e2 f7       	brpl	.-8      	; 0xf0 <DIO_VidSetPinDir+0x5e>
      f8:	82 2b       	or	r24, r18
      fa:	81 bb       	out	0x11, r24	; 17
      fc:	08 95       	ret
      fe:	41 11       	cpse	r20, r1
     100:	37 c0       	rjmp	.+110    	; 0x170 <DIO_VidSetPinDir+0xde>
     102:	81 30       	cpi	r24, 0x01	; 1
     104:	91 f0       	breq	.+36     	; 0x12a <DIO_VidSetPinDir+0x98>
     106:	28 f0       	brcs	.+10     	; 0x112 <DIO_VidSetPinDir+0x80>
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	d9 f0       	breq	.+54     	; 0x142 <DIO_VidSetPinDir+0xb0>
     10c:	83 30       	cpi	r24, 0x03	; 3
     10e:	29 f1       	breq	.+74     	; 0x15a <DIO_VidSetPinDir+0xc8>
     110:	08 95       	ret
     112:	2a b3       	in	r18, 0x1a	; 26
     114:	81 e0       	ldi	r24, 0x01	; 1
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	02 c0       	rjmp	.+4      	; 0x11e <DIO_VidSetPinDir+0x8c>
     11a:	88 0f       	add	r24, r24
     11c:	99 1f       	adc	r25, r25
     11e:	6a 95       	dec	r22
     120:	e2 f7       	brpl	.-8      	; 0x11a <DIO_VidSetPinDir+0x88>
     122:	80 95       	com	r24
     124:	82 23       	and	r24, r18
     126:	8a bb       	out	0x1a, r24	; 26
     128:	08 95       	ret
     12a:	27 b3       	in	r18, 0x17	; 23
     12c:	81 e0       	ldi	r24, 0x01	; 1
     12e:	90 e0       	ldi	r25, 0x00	; 0
     130:	02 c0       	rjmp	.+4      	; 0x136 <DIO_VidSetPinDir+0xa4>
     132:	88 0f       	add	r24, r24
     134:	99 1f       	adc	r25, r25
     136:	6a 95       	dec	r22
     138:	e2 f7       	brpl	.-8      	; 0x132 <DIO_VidSetPinDir+0xa0>
     13a:	80 95       	com	r24
     13c:	82 23       	and	r24, r18
     13e:	87 bb       	out	0x17, r24	; 23
     140:	08 95       	ret
     142:	24 b3       	in	r18, 0x14	; 20
     144:	81 e0       	ldi	r24, 0x01	; 1
     146:	90 e0       	ldi	r25, 0x00	; 0
     148:	02 c0       	rjmp	.+4      	; 0x14e <DIO_VidSetPinDir+0xbc>
     14a:	88 0f       	add	r24, r24
     14c:	99 1f       	adc	r25, r25
     14e:	6a 95       	dec	r22
     150:	e2 f7       	brpl	.-8      	; 0x14a <DIO_VidSetPinDir+0xb8>
     152:	80 95       	com	r24
     154:	82 23       	and	r24, r18
     156:	84 bb       	out	0x14, r24	; 20
     158:	08 95       	ret
     15a:	21 b3       	in	r18, 0x11	; 17
     15c:	81 e0       	ldi	r24, 0x01	; 1
     15e:	90 e0       	ldi	r25, 0x00	; 0
     160:	02 c0       	rjmp	.+4      	; 0x166 <DIO_VidSetPinDir+0xd4>
     162:	88 0f       	add	r24, r24
     164:	99 1f       	adc	r25, r25
     166:	6a 95       	dec	r22
     168:	e2 f7       	brpl	.-8      	; 0x162 <DIO_VidSetPinDir+0xd0>
     16a:	80 95       	com	r24
     16c:	82 23       	and	r24, r18
     16e:	81 bb       	out	0x11, r24	; 17
     170:	08 95       	ret

00000172 <DIO_VidSetPinVal>:
     172:	41 11       	cpse	r20, r1
     174:	34 c0       	rjmp	.+104    	; 0x1de <DIO_VidSetPinVal+0x6c>
     176:	81 30       	cpi	r24, 0x01	; 1
     178:	89 f0       	breq	.+34     	; 0x19c <DIO_VidSetPinVal+0x2a>
     17a:	28 f0       	brcs	.+10     	; 0x186 <DIO_VidSetPinVal+0x14>
     17c:	82 30       	cpi	r24, 0x02	; 2
     17e:	c9 f0       	breq	.+50     	; 0x1b2 <DIO_VidSetPinVal+0x40>
     180:	83 30       	cpi	r24, 0x03	; 3
     182:	11 f1       	breq	.+68     	; 0x1c8 <DIO_VidSetPinVal+0x56>
     184:	08 95       	ret
     186:	2b b3       	in	r18, 0x1b	; 27
     188:	81 e0       	ldi	r24, 0x01	; 1
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	02 c0       	rjmp	.+4      	; 0x192 <DIO_VidSetPinVal+0x20>
     18e:	88 0f       	add	r24, r24
     190:	99 1f       	adc	r25, r25
     192:	6a 95       	dec	r22
     194:	e2 f7       	brpl	.-8      	; 0x18e <DIO_VidSetPinVal+0x1c>
     196:	82 2b       	or	r24, r18
     198:	8b bb       	out	0x1b, r24	; 27
     19a:	08 95       	ret
     19c:	28 b3       	in	r18, 0x18	; 24
     19e:	81 e0       	ldi	r24, 0x01	; 1
     1a0:	90 e0       	ldi	r25, 0x00	; 0
     1a2:	02 c0       	rjmp	.+4      	; 0x1a8 <DIO_VidSetPinVal+0x36>
     1a4:	88 0f       	add	r24, r24
     1a6:	99 1f       	adc	r25, r25
     1a8:	6a 95       	dec	r22
     1aa:	e2 f7       	brpl	.-8      	; 0x1a4 <DIO_VidSetPinVal+0x32>
     1ac:	82 2b       	or	r24, r18
     1ae:	88 bb       	out	0x18, r24	; 24
     1b0:	08 95       	ret
     1b2:	25 b3       	in	r18, 0x15	; 21
     1b4:	81 e0       	ldi	r24, 0x01	; 1
     1b6:	90 e0       	ldi	r25, 0x00	; 0
     1b8:	02 c0       	rjmp	.+4      	; 0x1be <DIO_VidSetPinVal+0x4c>
     1ba:	88 0f       	add	r24, r24
     1bc:	99 1f       	adc	r25, r25
     1be:	6a 95       	dec	r22
     1c0:	e2 f7       	brpl	.-8      	; 0x1ba <DIO_VidSetPinVal+0x48>
     1c2:	82 2b       	or	r24, r18
     1c4:	85 bb       	out	0x15, r24	; 21
     1c6:	08 95       	ret
     1c8:	22 b3       	in	r18, 0x12	; 18
     1ca:	81 e0       	ldi	r24, 0x01	; 1
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	02 c0       	rjmp	.+4      	; 0x1d4 <DIO_VidSetPinVal+0x62>
     1d0:	88 0f       	add	r24, r24
     1d2:	99 1f       	adc	r25, r25
     1d4:	6a 95       	dec	r22
     1d6:	e2 f7       	brpl	.-8      	; 0x1d0 <DIO_VidSetPinVal+0x5e>
     1d8:	82 2b       	or	r24, r18
     1da:	82 bb       	out	0x12, r24	; 18
     1dc:	08 95       	ret
     1de:	41 30       	cpi	r20, 0x01	; 1
     1e0:	b9 f5       	brne	.+110    	; 0x250 <DIO_VidSetPinVal+0xde>
     1e2:	81 30       	cpi	r24, 0x01	; 1
     1e4:	91 f0       	breq	.+36     	; 0x20a <DIO_VidSetPinVal+0x98>
     1e6:	28 f0       	brcs	.+10     	; 0x1f2 <DIO_VidSetPinVal+0x80>
     1e8:	82 30       	cpi	r24, 0x02	; 2
     1ea:	d9 f0       	breq	.+54     	; 0x222 <DIO_VidSetPinVal+0xb0>
     1ec:	83 30       	cpi	r24, 0x03	; 3
     1ee:	29 f1       	breq	.+74     	; 0x23a <DIO_VidSetPinVal+0xc8>
     1f0:	08 95       	ret
     1f2:	2b b3       	in	r18, 0x1b	; 27
     1f4:	81 e0       	ldi	r24, 0x01	; 1
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	02 c0       	rjmp	.+4      	; 0x1fe <DIO_VidSetPinVal+0x8c>
     1fa:	88 0f       	add	r24, r24
     1fc:	99 1f       	adc	r25, r25
     1fe:	6a 95       	dec	r22
     200:	e2 f7       	brpl	.-8      	; 0x1fa <DIO_VidSetPinVal+0x88>
     202:	80 95       	com	r24
     204:	82 23       	and	r24, r18
     206:	8b bb       	out	0x1b, r24	; 27
     208:	08 95       	ret
     20a:	28 b3       	in	r18, 0x18	; 24
     20c:	81 e0       	ldi	r24, 0x01	; 1
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	02 c0       	rjmp	.+4      	; 0x216 <DIO_VidSetPinVal+0xa4>
     212:	88 0f       	add	r24, r24
     214:	99 1f       	adc	r25, r25
     216:	6a 95       	dec	r22
     218:	e2 f7       	brpl	.-8      	; 0x212 <DIO_VidSetPinVal+0xa0>
     21a:	80 95       	com	r24
     21c:	82 23       	and	r24, r18
     21e:	88 bb       	out	0x18, r24	; 24
     220:	08 95       	ret
     222:	25 b3       	in	r18, 0x15	; 21
     224:	81 e0       	ldi	r24, 0x01	; 1
     226:	90 e0       	ldi	r25, 0x00	; 0
     228:	02 c0       	rjmp	.+4      	; 0x22e <DIO_VidSetPinVal+0xbc>
     22a:	88 0f       	add	r24, r24
     22c:	99 1f       	adc	r25, r25
     22e:	6a 95       	dec	r22
     230:	e2 f7       	brpl	.-8      	; 0x22a <DIO_VidSetPinVal+0xb8>
     232:	80 95       	com	r24
     234:	82 23       	and	r24, r18
     236:	85 bb       	out	0x15, r24	; 21
     238:	08 95       	ret
     23a:	22 b3       	in	r18, 0x12	; 18
     23c:	81 e0       	ldi	r24, 0x01	; 1
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	02 c0       	rjmp	.+4      	; 0x246 <DIO_VidSetPinVal+0xd4>
     242:	88 0f       	add	r24, r24
     244:	99 1f       	adc	r25, r25
     246:	6a 95       	dec	r22
     248:	e2 f7       	brpl	.-8      	; 0x242 <DIO_VidSetPinVal+0xd0>
     24a:	80 95       	com	r24
     24c:	82 23       	and	r24, r18
     24e:	82 bb       	out	0x12, r24	; 18
     250:	08 95       	ret

00000252 <DIO_u8GetPinValue>:
		}
}
u8 DIO_u8GetPinValue(u8 Copy_u8Port,u8 Copy_u8PinNo)
{
	u8 Local_u8Reading=0;
	if(Copy_u8PinNo<8)
     252:	68 30       	cpi	r22, 0x08	; 8
     254:	60 f5       	brcc	.+88     	; 0x2ae <DIO_u8GetPinValue+0x5c>
	{
		switch(Copy_u8Port)
     256:	81 30       	cpi	r24, 0x01	; 1
     258:	79 f0       	breq	.+30     	; 0x278 <DIO_u8GetPinValue+0x26>
     25a:	28 f0       	brcs	.+10     	; 0x266 <DIO_u8GetPinValue+0x14>
     25c:	82 30       	cpi	r24, 0x02	; 2
     25e:	a9 f0       	breq	.+42     	; 0x28a <DIO_u8GetPinValue+0x38>
     260:	83 30       	cpi	r24, 0x03	; 3
     262:	e1 f0       	breq	.+56     	; 0x29c <DIO_u8GetPinValue+0x4a>
     264:	26 c0       	rjmp	.+76     	; 0x2b2 <DIO_u8GetPinValue+0x60>
		{
		case PORT_A: Local_u8Reading = GET_BIT(PINA,Copy_u8PinNo); break;
     266:	89 b3       	in	r24, 0x19	; 25
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	02 c0       	rjmp	.+4      	; 0x270 <DIO_u8GetPinValue+0x1e>
     26c:	95 95       	asr	r25
     26e:	87 95       	ror	r24
     270:	6a 95       	dec	r22
     272:	e2 f7       	brpl	.-8      	; 0x26c <DIO_u8GetPinValue+0x1a>
     274:	81 70       	andi	r24, 0x01	; 1
     276:	08 95       	ret
		case PORT_B: Local_u8Reading = GET_BIT(PINB,Copy_u8PinNo); break;
     278:	86 b3       	in	r24, 0x16	; 22
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	02 c0       	rjmp	.+4      	; 0x282 <DIO_u8GetPinValue+0x30>
     27e:	95 95       	asr	r25
     280:	87 95       	ror	r24
     282:	6a 95       	dec	r22
     284:	e2 f7       	brpl	.-8      	; 0x27e <DIO_u8GetPinValue+0x2c>
     286:	81 70       	andi	r24, 0x01	; 1
     288:	08 95       	ret
		case PORT_C: Local_u8Reading = GET_BIT(PINC,Copy_u8PinNo); break;
     28a:	83 b3       	in	r24, 0x13	; 19
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	02 c0       	rjmp	.+4      	; 0x294 <DIO_u8GetPinValue+0x42>
     290:	95 95       	asr	r25
     292:	87 95       	ror	r24
     294:	6a 95       	dec	r22
     296:	e2 f7       	brpl	.-8      	; 0x290 <DIO_u8GetPinValue+0x3e>
     298:	81 70       	andi	r24, 0x01	; 1
     29a:	08 95       	ret
		case PORT_D: Local_u8Reading = GET_BIT(PIND,Copy_u8PinNo); break;
     29c:	80 b3       	in	r24, 0x10	; 16
     29e:	90 e0       	ldi	r25, 0x00	; 0
     2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <DIO_u8GetPinValue+0x54>
     2a2:	95 95       	asr	r25
     2a4:	87 95       	ror	r24
     2a6:	6a 95       	dec	r22
     2a8:	e2 f7       	brpl	.-8      	; 0x2a2 <DIO_u8GetPinValue+0x50>
     2aa:	81 70       	andi	r24, 0x01	; 1
     2ac:	08 95       	ret
			case PORT_D: *pu8Value=GET_BIT(PIND,copy_u8Pin); break;
		}
}
u8 DIO_u8GetPinValue(u8 Copy_u8Port,u8 Copy_u8PinNo)
{
	u8 Local_u8Reading=0;
     2ae:	80 e0       	ldi	r24, 0x00	; 0
     2b0:	08 95       	ret
     2b2:	80 e0       	ldi	r24, 0x00	; 0
		case PORT_C: Local_u8Reading = GET_BIT(PINC,Copy_u8PinNo); break;
		case PORT_D: Local_u8Reading = GET_BIT(PIND,Copy_u8PinNo); break;
		}
	}
	return Local_u8Reading;
}
     2b4:	08 95       	ret

000002b6 <DIO_VidSetPortDir>:
//----ports

/*Set DIO Port Direction*/
void DIO_VidSetPortDir(u8 copy_u8Port,u8 copy_u8Direction)
{
	if (copy_u8Direction==Output)
     2b6:	61 30       	cpi	r22, 0x01	; 1
     2b8:	a1 f4       	brne	.+40     	; 0x2e2 <DIO_VidSetPortDir+0x2c>
	{
		switch (copy_u8Port)
     2ba:	81 30       	cpi	r24, 0x01	; 1
     2bc:	49 f0       	breq	.+18     	; 0x2d0 <DIO_VidSetPortDir+0x1a>
     2be:	28 f0       	brcs	.+10     	; 0x2ca <DIO_VidSetPortDir+0x14>
     2c0:	82 30       	cpi	r24, 0x02	; 2
     2c2:	49 f0       	breq	.+18     	; 0x2d6 <DIO_VidSetPortDir+0x20>
     2c4:	83 30       	cpi	r24, 0x03	; 3
     2c6:	51 f0       	breq	.+20     	; 0x2dc <DIO_VidSetPortDir+0x26>
     2c8:	08 95       	ret
		{
			case PORT_A: DDRA =0xff; break;
     2ca:	8f ef       	ldi	r24, 0xFF	; 255
     2cc:	8a bb       	out	0x1a, r24	; 26
     2ce:	08 95       	ret
			case PORT_B: DDRB =0xff; break;
     2d0:	8f ef       	ldi	r24, 0xFF	; 255
     2d2:	87 bb       	out	0x17, r24	; 23
     2d4:	08 95       	ret
			case PORT_C: DDRC =0xff; break;
     2d6:	8f ef       	ldi	r24, 0xFF	; 255
     2d8:	84 bb       	out	0x14, r24	; 20
     2da:	08 95       	ret
			case PORT_D: DDRD =0xff; break;
     2dc:	8f ef       	ldi	r24, 0xFF	; 255
     2de:	81 bb       	out	0x11, r24	; 17
     2e0:	08 95       	ret
		}
	}
	else if (copy_u8Direction==Input)
     2e2:	61 11       	cpse	r22, r1
     2e4:	0f c0       	rjmp	.+30     	; 0x304 <DIO_VidSetPortDir+0x4e>
	{
			switch (copy_u8Port)
     2e6:	81 30       	cpi	r24, 0x01	; 1
     2e8:	41 f0       	breq	.+16     	; 0x2fa <DIO_VidSetPortDir+0x44>
     2ea:	28 f0       	brcs	.+10     	; 0x2f6 <DIO_VidSetPortDir+0x40>
     2ec:	82 30       	cpi	r24, 0x02	; 2
     2ee:	39 f0       	breq	.+14     	; 0x2fe <DIO_VidSetPortDir+0x48>
     2f0:	83 30       	cpi	r24, 0x03	; 3
     2f2:	39 f0       	breq	.+14     	; 0x302 <DIO_VidSetPortDir+0x4c>
     2f4:	08 95       	ret
		{
			case PORT_A: DDRA =0x00; break;
     2f6:	1a ba       	out	0x1a, r1	; 26
     2f8:	08 95       	ret
			case PORT_B: DDRB =0x00; break;
     2fa:	17 ba       	out	0x17, r1	; 23
     2fc:	08 95       	ret
			case PORT_C: DDRC =0x00; break;
     2fe:	14 ba       	out	0x14, r1	; 20
     300:	08 95       	ret
			case PORT_D: DDRD =0x00; break;
     302:	11 ba       	out	0x11, r1	; 17
     304:	08 95       	ret

00000306 <DIO_VidSetPortVal>:
	}
}
/*Set DIO Port Value*/
void DIO_VidSetPortVal(u8 copy_u8Port,u8 copy_u8Value)
{
	switch (copy_u8Port)
     306:	81 30       	cpi	r24, 0x01	; 1
     308:	41 f0       	breq	.+16     	; 0x31a <DIO_VidSetPortVal+0x14>
     30a:	28 f0       	brcs	.+10     	; 0x316 <DIO_VidSetPortVal+0x10>
     30c:	82 30       	cpi	r24, 0x02	; 2
     30e:	39 f0       	breq	.+14     	; 0x31e <DIO_VidSetPortVal+0x18>
     310:	83 30       	cpi	r24, 0x03	; 3
     312:	39 f0       	breq	.+14     	; 0x322 <DIO_VidSetPortVal+0x1c>
     314:	08 95       	ret
		{
			case PORT_A: PORTA = copy_u8Value;  break;
     316:	6b bb       	out	0x1b, r22	; 27
     318:	08 95       	ret
			case PORT_B: PORTB = copy_u8Value;  break;
     31a:	68 bb       	out	0x18, r22	; 24
     31c:	08 95       	ret
			case PORT_C: PORTC = copy_u8Value;  break;
     31e:	65 bb       	out	0x15, r22	; 21
     320:	08 95       	ret
			case PORT_D: PORTD = copy_u8Value;  break;
     322:	62 bb       	out	0x12, r22	; 18
     324:	08 95       	ret

00000326 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     326:	cf 93       	push	r28
     328:	df 93       	push	r29
     32a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     32c:	0e 94 f6 05 	call	0xbec	; 0xbec <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     330:	20 91 0c 03 	lds	r18, 0x030C	; 0x80030c <__data_end>
     334:	30 91 0d 03 	lds	r19, 0x030D	; 0x80030d <__data_end+0x1>
     338:	c9 01       	movw	r24, r18
     33a:	8c 0f       	add	r24, r28
     33c:	9d 1f       	adc	r25, r29
     33e:	88 3e       	cpi	r24, 0xE8	; 232
     340:	43 e0       	ldi	r20, 0x03	; 3
     342:	94 07       	cpc	r25, r20
     344:	58 f4       	brcc	.+22     	; 0x35c <pvPortMalloc+0x36>
     346:	28 17       	cp	r18, r24
     348:	39 07       	cpc	r19, r25
     34a:	58 f4       	brcc	.+22     	; 0x362 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     34c:	e9 01       	movw	r28, r18
     34e:	c2 5f       	subi	r28, 0xF2	; 242
     350:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
     352:	90 93 0d 03 	sts	0x030D, r25	; 0x80030d <__data_end+0x1>
     356:	80 93 0c 03 	sts	0x030C, r24	; 0x80030c <__data_end>
     35a:	05 c0       	rjmp	.+10     	; 0x366 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     35c:	c0 e0       	ldi	r28, 0x00	; 0
     35e:	d0 e0       	ldi	r29, 0x00	; 0
     360:	02 c0       	rjmp	.+4      	; 0x366 <pvPortMalloc+0x40>
     362:	c0 e0       	ldi	r28, 0x00	; 0
     364:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     366:	0e 94 c0 06 	call	0xd80	; 0xd80 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     36a:	ce 01       	movw	r24, r28
     36c:	df 91       	pop	r29
     36e:	cf 91       	pop	r28
     370:	08 95       	ret

00000372 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     372:	08 95       	ret

00000374 <KPD_GetPressedKey>:
/*              pressed at the same time                               	     		   */
/* Input      ! Nothing                                                                */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void KPD_GetPressedKey(void*pvParameters)
{
     374:	0f 2e       	mov	r0, r31
     376:	f7 ef       	ldi	r31, 0xF7	; 247
     378:	ef 2e       	mov	r14, r31
     37a:	f2 e0       	ldi	r31, 0x02	; 2
     37c:	ff 2e       	mov	r15, r31
     37e:	f0 2d       	mov	r31, r0
	u8 LOC_u8Row;

                                                                   
while(1) {
	/* Looping on columns of the Key Pad */                                                                               
	for (LOC_u8Column = 0 + COL_INIT; LOC_u8Column < COL_FIN; LOC_u8Column++)
     380:	d4 e0       	ldi	r29, 0x04	; 4
	{
		/* Activate the Column                                                                                           */
		DIO_VidSetPinVal(PORT, LOC_u8Column, PinLow);
     382:	41 e0       	ldi	r20, 0x01	; 1
     384:	6d 2f       	mov	r22, r29
     386:	80 e0       	ldi	r24, 0x00	; 0
     388:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_VidSetPinVal>
     38c:	87 01       	movw	r16, r14

		/* Loop on the rows of the Key Pad */                                                                            
		for (LOC_u8Row = 0 + ROW_INIT; LOC_u8Row < ROW_FIN; LOC_u8Row++)
     38e:	c0 e0       	ldi	r28, 0x00	; 0
		{
			/* Check the status of the switch   */                                                                
			if (!DIO_u8GetPinValue(PORT, LOC_u8Row))
     390:	6c 2f       	mov	r22, r28
     392:	80 e0       	ldi	r24, 0x00	; 0
     394:	0e 94 29 01 	call	0x252	; 0x252 <DIO_u8GetPinValue>
     398:	81 11       	cpse	r24, r1
     39a:	0a c0       	rjmp	.+20     	; 0x3b0 <KPD_GetPressedKey+0x3c>
			{
				/* Get the value of the currently pressed switch                                                             */
				key = KPD_au8SwitchVal[LOC_u8Column - COL_INIT][LOC_u8Row - ROW_INIT];
     39c:	f8 01       	movw	r30, r16
     39e:	80 81       	ld	r24, Z
     3a0:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <key>

				/* Wait until the switch is released (Single Press)                                                          */
				while (!DIO_u8GetPinValue(PORT, LOC_u8Row));
     3a4:	6c 2f       	mov	r22, r28
     3a6:	80 e0       	ldi	r24, 0x00	; 0
     3a8:	0e 94 29 01 	call	0x252	; 0x252 <DIO_u8GetPinValue>
     3ac:	88 23       	and	r24, r24
     3ae:	d1 f3       	breq	.-12     	; 0x3a4 <KPD_GetPressedKey+0x30>
	{
		/* Activate the Column                                                                                           */
		DIO_VidSetPinVal(PORT, LOC_u8Column, PinLow);

		/* Loop on the rows of the Key Pad */                                                                            
		for (LOC_u8Row = 0 + ROW_INIT; LOC_u8Row < ROW_FIN; LOC_u8Row++)
     3b0:	cf 5f       	subi	r28, 0xFF	; 255
     3b2:	0f 5f       	subi	r16, 0xFF	; 255
     3b4:	1f 4f       	sbci	r17, 0xFF	; 255
     3b6:	c4 30       	cpi	r28, 0x04	; 4
     3b8:	59 f7       	brne	.-42     	; 0x390 <KPD_GetPressedKey+0x1c>
			
			}
		}
		
		/* Deactivate the Column                                                                                         */
		DIO_VidSetPinVal(PORT, LOC_u8Column, PinHigh);
     3ba:	40 e0       	ldi	r20, 0x00	; 0
     3bc:	6d 2f       	mov	r22, r29
     3be:	80 e0       	ldi	r24, 0x00	; 0
     3c0:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_VidSetPinVal>
	u8 LOC_u8Row;

                                                                   
while(1) {
	/* Looping on columns of the Key Pad */                                                                               
	for (LOC_u8Column = 0 + COL_INIT; LOC_u8Column < COL_FIN; LOC_u8Column++)
     3c4:	df 5f       	subi	r29, 0xFF	; 255
     3c6:	f4 e0       	ldi	r31, 0x04	; 4
     3c8:	ef 0e       	add	r14, r31
     3ca:	f1 1c       	adc	r15, r1
     3cc:	d8 30       	cpi	r29, 0x08	; 8
     3ce:	c9 f6       	brne	.-78     	; 0x382 <KPD_GetPressedKey+0xe>
		}
		
		/* Deactivate the Column                                                                                         */
		DIO_VidSetPinVal(PORT, LOC_u8Column, PinHigh);
	}
		vTaskDelay(1);
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	0e 94 46 07 	call	0xe8c	; 0xe8c <vTaskDelay>
}
     3d8:	cd cf       	rjmp	.-102    	; 0x374 <KPD_GetPressedKey>

000003da <KPD_vidInit>:
}


void KPD_vidInit(void)
{
	DIO_VidSetPinDir(PORT,Pin_0,Input);
     3da:	40 e0       	ldi	r20, 0x00	; 0
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	80 e0       	ldi	r24, 0x00	; 0
     3e0:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinDir(PORT,Pin_1,Input);
     3e4:	40 e0       	ldi	r20, 0x00	; 0
     3e6:	61 e0       	ldi	r22, 0x01	; 1
     3e8:	80 e0       	ldi	r24, 0x00	; 0
     3ea:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinDir(PORT,Pin_2,Input);
     3ee:	40 e0       	ldi	r20, 0x00	; 0
     3f0:	62 e0       	ldi	r22, 0x02	; 2
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinDir(PORT,Pin_3,Input);
     3f8:	40 e0       	ldi	r20, 0x00	; 0
     3fa:	63 e0       	ldi	r22, 0x03	; 3
     3fc:	80 e0       	ldi	r24, 0x00	; 0
     3fe:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinDir(PORT,Pin_4,Output);
     402:	41 e0       	ldi	r20, 0x01	; 1
     404:	64 e0       	ldi	r22, 0x04	; 4
     406:	80 e0       	ldi	r24, 0x00	; 0
     408:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinDir(PORT,Pin_5,Output);
     40c:	41 e0       	ldi	r20, 0x01	; 1
     40e:	65 e0       	ldi	r22, 0x05	; 5
     410:	80 e0       	ldi	r24, 0x00	; 0
     412:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinDir(PORT,Pin_6,Output);
     416:	41 e0       	ldi	r20, 0x01	; 1
     418:	66 e0       	ldi	r22, 0x06	; 6
     41a:	80 e0       	ldi	r24, 0x00	; 0
     41c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinDir(PORT,Pin_7,Output);
     420:	41 e0       	ldi	r20, 0x01	; 1
     422:	67 e0       	ldi	r22, 0x07	; 7
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	0e 94 49 00 	call	0x92	; 0x92 <DIO_VidSetPinDir>
	DIO_VidSetPinVal(PORT,Pin_0,PinHigh);
     42a:	40 e0       	ldi	r20, 0x00	; 0
     42c:	60 e0       	ldi	r22, 0x00	; 0
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_VidSetPinVal>
	DIO_VidSetPinVal(PORT,Pin_1,PinHigh);
     434:	40 e0       	ldi	r20, 0x00	; 0
     436:	61 e0       	ldi	r22, 0x01	; 1
     438:	80 e0       	ldi	r24, 0x00	; 0
     43a:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_VidSetPinVal>
	DIO_VidSetPinVal(PORT,Pin_2,PinHigh);
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	62 e0       	ldi	r22, 0x02	; 2
     442:	80 e0       	ldi	r24, 0x00	; 0
     444:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_VidSetPinVal>
	DIO_VidSetPinVal(PORT,Pin_3,PinHigh);
     448:	40 e0       	ldi	r20, 0x00	; 0
     44a:	63 e0       	ldi	r22, 0x03	; 3
     44c:	80 e0       	ldi	r24, 0x00	; 0
     44e:	0e 94 b9 00 	call	0x172	; 0x172 <DIO_VidSetPinVal>
     452:	08 95       	ret

00000454 <LED_vidInit>:
};
    u8 NumberOfPatterns = (sizeof(patterns)/sizeof(patterns[0]));
void LED_vidInit(void)
{
	/*Set Led Port direction as output*/
	DIO_VidSetPortDir(Animation_Port,Output);
     454:	61 e0       	ldi	r22, 0x01	; 1
     456:	82 e0       	ldi	r24, 0x02	; 2
     458:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <DIO_VidSetPortDir>
     45c:	08 95       	ret

0000045e <LED_vidActivatePattern>:
	i=0;
	localcounter=0;
	currentstate=key;

}
if((patterns[currentstate].pattern[i])==-1)
     45e:	c2 e4       	ldi	r28, 0x42	; 66
{
	u8  static i=0;
	u16  static localcounter=0;
while(1)
{
localcounter++;
     460:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <localcounter.1860>
     464:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <localcounter.1860+0x1>
     468:	01 96       	adiw	r24, 0x01	; 1
     46a:	90 93 f9 06 	sts	0x06F9, r25	; 0x8006f9 <localcounter.1860+0x1>
     46e:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <localcounter.1860>
if(Valid_pattern)
     472:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <key>
     476:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <currentstate>
     47a:	98 17       	cp	r25, r24
     47c:	20 f4       	brcc	.+8      	; 0x486 <LED_vidActivatePattern+0x28>
     47e:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <NumberOfPatterns>
     482:	89 17       	cp	r24, r25
     484:	10 f0       	brcs	.+4      	; 0x48a <LED_vidActivatePattern+0x2c>
     486:	81 11       	cpse	r24, r1
     488:	08 c0       	rjmp	.+16     	; 0x49a <LED_vidActivatePattern+0x3c>
{
	i=0;
     48a:	10 92 f7 06 	sts	0x06F7, r1	; 0x8006f7 <i.1859>
	localcounter=0;
     48e:	10 92 f9 06 	sts	0x06F9, r1	; 0x8006f9 <localcounter.1860+0x1>
     492:	10 92 f8 06 	sts	0x06F8, r1	; 0x8006f8 <localcounter.1860>
	currentstate=key;
     496:	80 93 fa 06 	sts	0x06FA, r24	; 0x8006fa <currentstate>

}
if((patterns[currentstate].pattern[i])==-1)
     49a:	80 91 fa 06 	lds	r24, 0x06FA	; 0x8006fa <currentstate>
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	20 91 f7 06 	lds	r18, 0x06F7	; 0x8006f7 <i.1859>
     4a4:	c8 9f       	mul	r28, r24
     4a6:	f0 01       	movw	r30, r0
     4a8:	c9 9f       	mul	r28, r25
     4aa:	f0 0d       	add	r31, r0
     4ac:	11 24       	eor	r1, r1
     4ae:	34 e0       	ldi	r19, 0x04	; 4
     4b0:	23 9f       	mul	r18, r19
     4b2:	e0 0d       	add	r30, r0
     4b4:	f1 1d       	adc	r31, r1
     4b6:	11 24       	eor	r1, r1
     4b8:	ef 59       	subi	r30, 0x9F	; 159
     4ba:	ff 4f       	sbci	r31, 0xFF	; 255
     4bc:	42 81       	ldd	r20, Z+2	; 0x02
     4be:	53 81       	ldd	r21, Z+3	; 0x03
     4c0:	64 81       	ldd	r22, Z+4	; 0x04
     4c2:	75 81       	ldd	r23, Z+5	; 0x05
     4c4:	4f 3f       	cpi	r20, 0xFF	; 255
     4c6:	5f 4f       	sbci	r21, 0xFF	; 255
     4c8:	6f 4f       	sbci	r22, 0xFF	; 255
     4ca:	7f 4f       	sbci	r23, 0xFF	; 255
     4cc:	11 f4       	brne	.+4      	; 0x4d2 <LED_vidActivatePattern+0x74>
{
	i=0;
     4ce:	10 92 f7 06 	sts	0x06F7, r1	; 0x8006f7 <i.1859>
}
if(localcounter==patterns[currentstate].delay){
     4d2:	c8 9f       	mul	r28, r24
     4d4:	f0 01       	movw	r30, r0
     4d6:	c9 9f       	mul	r28, r25
     4d8:	f0 0d       	add	r31, r0
     4da:	11 24       	eor	r1, r1
     4dc:	ef 59       	subi	r30, 0x9F	; 159
     4de:	ff 4f       	sbci	r31, 0xFF	; 255
     4e0:	40 81       	ld	r20, Z
     4e2:	51 81       	ldd	r21, Z+1	; 0x01
     4e4:	20 91 f8 06 	lds	r18, 0x06F8	; 0x8006f8 <localcounter.1860>
     4e8:	30 91 f9 06 	lds	r19, 0x06F9	; 0x8006f9 <localcounter.1860+0x1>
     4ec:	42 17       	cp	r20, r18
     4ee:	53 07       	cpc	r21, r19
     4f0:	49 f4       	brne	.+18     	; 0x504 <LED_vidActivatePattern+0xa6>
i++;
     4f2:	20 91 f7 06 	lds	r18, 0x06F7	; 0x8006f7 <i.1859>
     4f6:	2f 5f       	subi	r18, 0xFF	; 255
     4f8:	20 93 f7 06 	sts	0x06F7, r18	; 0x8006f7 <i.1859>
localcounter=0;
     4fc:	10 92 f9 06 	sts	0x06F9, r1	; 0x8006f9 <localcounter.1860+0x1>
     500:	10 92 f8 06 	sts	0x06F8, r1	; 0x8006f8 <localcounter.1860>

}
DIO_VidSetPortVal(Animation_Port,patterns[currentstate].pattern[i]);
     504:	20 91 f7 06 	lds	r18, 0x06F7	; 0x8006f7 <i.1859>
     508:	c8 9f       	mul	r28, r24
     50a:	f0 01       	movw	r30, r0
     50c:	c9 9f       	mul	r28, r25
     50e:	f0 0d       	add	r31, r0
     510:	11 24       	eor	r1, r1
     512:	34 e0       	ldi	r19, 0x04	; 4
     514:	23 9f       	mul	r18, r19
     516:	e0 0d       	add	r30, r0
     518:	f1 1d       	adc	r31, r1
     51a:	11 24       	eor	r1, r1
     51c:	ef 59       	subi	r30, 0x9F	; 159
     51e:	ff 4f       	sbci	r31, 0xFF	; 255
     520:	62 81       	ldd	r22, Z+2	; 0x02
     522:	82 e0       	ldi	r24, 0x02	; 2
     524:	0e 94 83 01 	call	0x306	; 0x306 <DIO_VidSetPortVal>

vTaskDelay(1);
     528:	81 e0       	ldi	r24, 0x01	; 1
     52a:	90 e0       	ldi	r25, 0x00	; 0
     52c:	0e 94 46 07 	call	0xe8c	; 0xe8c <vTaskDelay>

}
     530:	97 cf       	rjmp	.-210    	; 0x460 <LED_vidActivatePattern+0x2>

00000532 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     532:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     534:	03 96       	adiw	r24, 0x03	; 3
     536:	92 83       	std	Z+2, r25	; 0x02
     538:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     53a:	2f ef       	ldi	r18, 0xFF	; 255
     53c:	3f ef       	ldi	r19, 0xFF	; 255
     53e:	34 83       	std	Z+4, r19	; 0x04
     540:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     542:	96 83       	std	Z+6, r25	; 0x06
     544:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     546:	90 87       	std	Z+8, r25	; 0x08
     548:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     54a:	10 82       	st	Z, r1
     54c:	08 95       	ret

0000054e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     54e:	fc 01       	movw	r30, r24
     550:	11 86       	std	Z+9, r1	; 0x09
     552:	10 86       	std	Z+8, r1	; 0x08
     554:	08 95       	ret

00000556 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     556:	cf 93       	push	r28
     558:	df 93       	push	r29
     55a:	fc 01       	movw	r30, r24
     55c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     55e:	21 81       	ldd	r18, Z+1	; 0x01
     560:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     562:	e9 01       	movw	r28, r18
     564:	8a 81       	ldd	r24, Y+2	; 0x02
     566:	9b 81       	ldd	r25, Y+3	; 0x03
     568:	13 96       	adiw	r26, 0x03	; 3
     56a:	9c 93       	st	X, r25
     56c:	8e 93       	st	-X, r24
     56e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     570:	81 81       	ldd	r24, Z+1	; 0x01
     572:	92 81       	ldd	r25, Z+2	; 0x02
     574:	15 96       	adiw	r26, 0x05	; 5
     576:	9c 93       	st	X, r25
     578:	8e 93       	st	-X, r24
     57a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     57c:	8a 81       	ldd	r24, Y+2	; 0x02
     57e:	9b 81       	ldd	r25, Y+3	; 0x03
     580:	ec 01       	movw	r28, r24
     582:	7d 83       	std	Y+5, r23	; 0x05
     584:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     586:	e9 01       	movw	r28, r18
     588:	7b 83       	std	Y+3, r23	; 0x03
     58a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     58c:	72 83       	std	Z+2, r23	; 0x02
     58e:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     590:	19 96       	adiw	r26, 0x09	; 9
     592:	fc 93       	st	X, r31
     594:	ee 93       	st	-X, r30
     596:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     598:	80 81       	ld	r24, Z
     59a:	8f 5f       	subi	r24, 0xFF	; 255
     59c:	80 83       	st	Z, r24
}
     59e:	df 91       	pop	r29
     5a0:	cf 91       	pop	r28
     5a2:	08 95       	ret

000005a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     5a4:	cf 93       	push	r28
     5a6:	df 93       	push	r29
     5a8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     5aa:	48 81       	ld	r20, Y
     5ac:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5ae:	4f 3f       	cpi	r20, 0xFF	; 255
     5b0:	2f ef       	ldi	r18, 0xFF	; 255
     5b2:	52 07       	cpc	r21, r18
     5b4:	31 f4       	brne	.+12     	; 0x5c2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5b6:	dc 01       	movw	r26, r24
     5b8:	17 96       	adiw	r26, 0x07	; 7
     5ba:	ed 91       	ld	r30, X+
     5bc:	fc 91       	ld	r31, X
     5be:	18 97       	sbiw	r26, 0x08	; 8
     5c0:	17 c0       	rjmp	.+46     	; 0x5f0 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     5c2:	fc 01       	movw	r30, r24
     5c4:	33 96       	adiw	r30, 0x03	; 3
     5c6:	dc 01       	movw	r26, r24
     5c8:	15 96       	adiw	r26, 0x05	; 5
     5ca:	2d 91       	ld	r18, X+
     5cc:	3c 91       	ld	r19, X
     5ce:	16 97       	sbiw	r26, 0x06	; 6
     5d0:	d9 01       	movw	r26, r18
     5d2:	2d 91       	ld	r18, X+
     5d4:	3c 91       	ld	r19, X
     5d6:	42 17       	cp	r20, r18
     5d8:	53 07       	cpc	r21, r19
     5da:	50 f0       	brcs	.+20     	; 0x5f0 <vListInsert+0x4c>
     5dc:	02 80       	ldd	r0, Z+2	; 0x02
     5de:	f3 81       	ldd	r31, Z+3	; 0x03
     5e0:	e0 2d       	mov	r30, r0
     5e2:	a2 81       	ldd	r26, Z+2	; 0x02
     5e4:	b3 81       	ldd	r27, Z+3	; 0x03
     5e6:	2d 91       	ld	r18, X+
     5e8:	3c 91       	ld	r19, X
     5ea:	42 17       	cp	r20, r18
     5ec:	53 07       	cpc	r21, r19
     5ee:	b0 f7       	brcc	.-20     	; 0x5dc <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5f0:	a2 81       	ldd	r26, Z+2	; 0x02
     5f2:	b3 81       	ldd	r27, Z+3	; 0x03
     5f4:	bb 83       	std	Y+3, r27	; 0x03
     5f6:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     5f8:	15 96       	adiw	r26, 0x05	; 5
     5fa:	dc 93       	st	X, r29
     5fc:	ce 93       	st	-X, r28
     5fe:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     600:	fd 83       	std	Y+5, r31	; 0x05
     602:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     604:	d3 83       	std	Z+3, r29	; 0x03
     606:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     608:	99 87       	std	Y+9, r25	; 0x09
     60a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     60c:	fc 01       	movw	r30, r24
     60e:	20 81       	ld	r18, Z
     610:	2f 5f       	subi	r18, 0xFF	; 255
     612:	20 83       	st	Z, r18
}
     614:	df 91       	pop	r29
     616:	cf 91       	pop	r28
     618:	08 95       	ret

0000061a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     61a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     61c:	a2 81       	ldd	r26, Z+2	; 0x02
     61e:	b3 81       	ldd	r27, Z+3	; 0x03
     620:	84 81       	ldd	r24, Z+4	; 0x04
     622:	95 81       	ldd	r25, Z+5	; 0x05
     624:	15 96       	adiw	r26, 0x05	; 5
     626:	9c 93       	st	X, r25
     628:	8e 93       	st	-X, r24
     62a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     62c:	a4 81       	ldd	r26, Z+4	; 0x04
     62e:	b5 81       	ldd	r27, Z+5	; 0x05
     630:	82 81       	ldd	r24, Z+2	; 0x02
     632:	93 81       	ldd	r25, Z+3	; 0x03
     634:	13 96       	adiw	r26, 0x03	; 3
     636:	9c 93       	st	X, r25
     638:	8e 93       	st	-X, r24
     63a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     63c:	a0 85       	ldd	r26, Z+8	; 0x08
     63e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     640:	11 96       	adiw	r26, 0x01	; 1
     642:	8d 91       	ld	r24, X+
     644:	9c 91       	ld	r25, X
     646:	12 97       	sbiw	r26, 0x02	; 2
     648:	e8 17       	cp	r30, r24
     64a:	f9 07       	cpc	r31, r25
     64c:	31 f4       	brne	.+12     	; 0x65a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     64e:	84 81       	ldd	r24, Z+4	; 0x04
     650:	95 81       	ldd	r25, Z+5	; 0x05
     652:	12 96       	adiw	r26, 0x02	; 2
     654:	9c 93       	st	X, r25
     656:	8e 93       	st	-X, r24
     658:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     65a:	11 86       	std	Z+9, r1	; 0x09
     65c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     65e:	8c 91       	ld	r24, X
     660:	81 50       	subi	r24, 0x01	; 1
     662:	8c 93       	st	X, r24
     664:	08 95       	ret

00000666 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     666:	31 e1       	ldi	r19, 0x11	; 17
     668:	fc 01       	movw	r30, r24
     66a:	30 83       	st	Z, r19
     66c:	31 97       	sbiw	r30, 0x01	; 1
     66e:	22 e2       	ldi	r18, 0x22	; 34
     670:	20 83       	st	Z, r18
     672:	31 97       	sbiw	r30, 0x01	; 1
     674:	a3 e3       	ldi	r26, 0x33	; 51
     676:	a0 83       	st	Z, r26
     678:	31 97       	sbiw	r30, 0x01	; 1
     67a:	60 83       	st	Z, r22
     67c:	31 97       	sbiw	r30, 0x01	; 1
     67e:	70 83       	st	Z, r23
     680:	31 97       	sbiw	r30, 0x01	; 1
     682:	10 82       	st	Z, r1
     684:	31 97       	sbiw	r30, 0x01	; 1
     686:	60 e8       	ldi	r22, 0x80	; 128
     688:	60 83       	st	Z, r22
     68a:	31 97       	sbiw	r30, 0x01	; 1
     68c:	10 82       	st	Z, r1
     68e:	31 97       	sbiw	r30, 0x01	; 1
     690:	62 e0       	ldi	r22, 0x02	; 2
     692:	60 83       	st	Z, r22
     694:	31 97       	sbiw	r30, 0x01	; 1
     696:	63 e0       	ldi	r22, 0x03	; 3
     698:	60 83       	st	Z, r22
     69a:	31 97       	sbiw	r30, 0x01	; 1
     69c:	64 e0       	ldi	r22, 0x04	; 4
     69e:	60 83       	st	Z, r22
     6a0:	31 97       	sbiw	r30, 0x01	; 1
     6a2:	65 e0       	ldi	r22, 0x05	; 5
     6a4:	60 83       	st	Z, r22
     6a6:	31 97       	sbiw	r30, 0x01	; 1
     6a8:	66 e0       	ldi	r22, 0x06	; 6
     6aa:	60 83       	st	Z, r22
     6ac:	31 97       	sbiw	r30, 0x01	; 1
     6ae:	67 e0       	ldi	r22, 0x07	; 7
     6b0:	60 83       	st	Z, r22
     6b2:	31 97       	sbiw	r30, 0x01	; 1
     6b4:	68 e0       	ldi	r22, 0x08	; 8
     6b6:	60 83       	st	Z, r22
     6b8:	31 97       	sbiw	r30, 0x01	; 1
     6ba:	69 e0       	ldi	r22, 0x09	; 9
     6bc:	60 83       	st	Z, r22
     6be:	31 97       	sbiw	r30, 0x01	; 1
     6c0:	60 e1       	ldi	r22, 0x10	; 16
     6c2:	60 83       	st	Z, r22
     6c4:	31 97       	sbiw	r30, 0x01	; 1
     6c6:	30 83       	st	Z, r19
     6c8:	31 97       	sbiw	r30, 0x01	; 1
     6ca:	32 e1       	ldi	r19, 0x12	; 18
     6cc:	30 83       	st	Z, r19
     6ce:	31 97       	sbiw	r30, 0x01	; 1
     6d0:	33 e1       	ldi	r19, 0x13	; 19
     6d2:	30 83       	st	Z, r19
     6d4:	31 97       	sbiw	r30, 0x01	; 1
     6d6:	34 e1       	ldi	r19, 0x14	; 20
     6d8:	30 83       	st	Z, r19
     6da:	31 97       	sbiw	r30, 0x01	; 1
     6dc:	35 e1       	ldi	r19, 0x15	; 21
     6de:	30 83       	st	Z, r19
     6e0:	31 97       	sbiw	r30, 0x01	; 1
     6e2:	36 e1       	ldi	r19, 0x16	; 22
     6e4:	30 83       	st	Z, r19
     6e6:	31 97       	sbiw	r30, 0x01	; 1
     6e8:	37 e1       	ldi	r19, 0x17	; 23
     6ea:	30 83       	st	Z, r19
     6ec:	31 97       	sbiw	r30, 0x01	; 1
     6ee:	38 e1       	ldi	r19, 0x18	; 24
     6f0:	30 83       	st	Z, r19
     6f2:	31 97       	sbiw	r30, 0x01	; 1
     6f4:	39 e1       	ldi	r19, 0x19	; 25
     6f6:	30 83       	st	Z, r19
     6f8:	31 97       	sbiw	r30, 0x01	; 1
     6fa:	30 e2       	ldi	r19, 0x20	; 32
     6fc:	30 83       	st	Z, r19
     6fe:	31 97       	sbiw	r30, 0x01	; 1
     700:	31 e2       	ldi	r19, 0x21	; 33
     702:	30 83       	st	Z, r19
     704:	31 97       	sbiw	r30, 0x01	; 1
     706:	20 83       	st	Z, r18
     708:	31 97       	sbiw	r30, 0x01	; 1
     70a:	23 e2       	ldi	r18, 0x23	; 35
     70c:	20 83       	st	Z, r18
     70e:	31 97       	sbiw	r30, 0x01	; 1
     710:	40 83       	st	Z, r20
     712:	31 97       	sbiw	r30, 0x01	; 1
     714:	50 83       	st	Z, r21
     716:	31 97       	sbiw	r30, 0x01	; 1
     718:	26 e2       	ldi	r18, 0x26	; 38
     71a:	20 83       	st	Z, r18
     71c:	31 97       	sbiw	r30, 0x01	; 1
     71e:	27 e2       	ldi	r18, 0x27	; 39
     720:	20 83       	st	Z, r18
     722:	31 97       	sbiw	r30, 0x01	; 1
     724:	28 e2       	ldi	r18, 0x28	; 40
     726:	20 83       	st	Z, r18
     728:	31 97       	sbiw	r30, 0x01	; 1
     72a:	29 e2       	ldi	r18, 0x29	; 41
     72c:	20 83       	st	Z, r18
     72e:	31 97       	sbiw	r30, 0x01	; 1
     730:	20 e3       	ldi	r18, 0x30	; 48
     732:	20 83       	st	Z, r18
     734:	31 97       	sbiw	r30, 0x01	; 1
     736:	21 e3       	ldi	r18, 0x31	; 49
     738:	20 83       	st	Z, r18
     73a:	86 97       	sbiw	r24, 0x26	; 38
     73c:	08 95       	ret

0000073e <xPortStartScheduler>:
     73e:	1b bc       	out	0x2b, r1	; 43
     740:	8c e7       	ldi	r24, 0x7C	; 124
     742:	8a bd       	out	0x2a, r24	; 42
     744:	8b e0       	ldi	r24, 0x0B	; 11
     746:	8e bd       	out	0x2e, r24	; 46
     748:	89 b7       	in	r24, 0x39	; 57
     74a:	80 61       	ori	r24, 0x10	; 16
     74c:	89 bf       	out	0x39, r24	; 57
     74e:	a0 91 5c 07 	lds	r26, 0x075C	; 0x80075c <pxCurrentTCB>
     752:	b0 91 5d 07 	lds	r27, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     756:	cd 91       	ld	r28, X+
     758:	cd bf       	out	0x3d, r28	; 61
     75a:	dd 91       	ld	r29, X+
     75c:	de bf       	out	0x3e, r29	; 62
     75e:	ff 91       	pop	r31
     760:	ef 91       	pop	r30
     762:	df 91       	pop	r29
     764:	cf 91       	pop	r28
     766:	bf 91       	pop	r27
     768:	af 91       	pop	r26
     76a:	9f 91       	pop	r25
     76c:	8f 91       	pop	r24
     76e:	7f 91       	pop	r23
     770:	6f 91       	pop	r22
     772:	5f 91       	pop	r21
     774:	4f 91       	pop	r20
     776:	3f 91       	pop	r19
     778:	2f 91       	pop	r18
     77a:	1f 91       	pop	r17
     77c:	0f 91       	pop	r16
     77e:	ff 90       	pop	r15
     780:	ef 90       	pop	r14
     782:	df 90       	pop	r13
     784:	cf 90       	pop	r12
     786:	bf 90       	pop	r11
     788:	af 90       	pop	r10
     78a:	9f 90       	pop	r9
     78c:	8f 90       	pop	r8
     78e:	7f 90       	pop	r7
     790:	6f 90       	pop	r6
     792:	5f 90       	pop	r5
     794:	4f 90       	pop	r4
     796:	3f 90       	pop	r3
     798:	2f 90       	pop	r2
     79a:	1f 90       	pop	r1
     79c:	0f 90       	pop	r0
     79e:	0f be       	out	0x3f, r0	; 63
     7a0:	0f 90       	pop	r0
     7a2:	08 95       	ret
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	08 95       	ret

000007a8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     7a8:	0f 92       	push	r0
     7aa:	0f b6       	in	r0, 0x3f	; 63
     7ac:	f8 94       	cli
     7ae:	0f 92       	push	r0
     7b0:	1f 92       	push	r1
     7b2:	11 24       	eor	r1, r1
     7b4:	2f 92       	push	r2
     7b6:	3f 92       	push	r3
     7b8:	4f 92       	push	r4
     7ba:	5f 92       	push	r5
     7bc:	6f 92       	push	r6
     7be:	7f 92       	push	r7
     7c0:	8f 92       	push	r8
     7c2:	9f 92       	push	r9
     7c4:	af 92       	push	r10
     7c6:	bf 92       	push	r11
     7c8:	cf 92       	push	r12
     7ca:	df 92       	push	r13
     7cc:	ef 92       	push	r14
     7ce:	ff 92       	push	r15
     7d0:	0f 93       	push	r16
     7d2:	1f 93       	push	r17
     7d4:	2f 93       	push	r18
     7d6:	3f 93       	push	r19
     7d8:	4f 93       	push	r20
     7da:	5f 93       	push	r21
     7dc:	6f 93       	push	r22
     7de:	7f 93       	push	r23
     7e0:	8f 93       	push	r24
     7e2:	9f 93       	push	r25
     7e4:	af 93       	push	r26
     7e6:	bf 93       	push	r27
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	ef 93       	push	r30
     7ee:	ff 93       	push	r31
     7f0:	a0 91 5c 07 	lds	r26, 0x075C	; 0x80075c <pxCurrentTCB>
     7f4:	b0 91 5d 07 	lds	r27, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     7f8:	0d b6       	in	r0, 0x3d	; 61
     7fa:	0d 92       	st	X+, r0
     7fc:	0e b6       	in	r0, 0x3e	; 62
     7fe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     800:	0e 94 96 07 	call	0xf2c	; 0xf2c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     804:	a0 91 5c 07 	lds	r26, 0x075C	; 0x80075c <pxCurrentTCB>
     808:	b0 91 5d 07 	lds	r27, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     80c:	cd 91       	ld	r28, X+
     80e:	cd bf       	out	0x3d, r28	; 61
     810:	dd 91       	ld	r29, X+
     812:	de bf       	out	0x3e, r29	; 62
     814:	ff 91       	pop	r31
     816:	ef 91       	pop	r30
     818:	df 91       	pop	r29
     81a:	cf 91       	pop	r28
     81c:	bf 91       	pop	r27
     81e:	af 91       	pop	r26
     820:	9f 91       	pop	r25
     822:	8f 91       	pop	r24
     824:	7f 91       	pop	r23
     826:	6f 91       	pop	r22
     828:	5f 91       	pop	r21
     82a:	4f 91       	pop	r20
     82c:	3f 91       	pop	r19
     82e:	2f 91       	pop	r18
     830:	1f 91       	pop	r17
     832:	0f 91       	pop	r16
     834:	ff 90       	pop	r15
     836:	ef 90       	pop	r14
     838:	df 90       	pop	r13
     83a:	cf 90       	pop	r12
     83c:	bf 90       	pop	r11
     83e:	af 90       	pop	r10
     840:	9f 90       	pop	r9
     842:	8f 90       	pop	r8
     844:	7f 90       	pop	r7
     846:	6f 90       	pop	r6
     848:	5f 90       	pop	r5
     84a:	4f 90       	pop	r4
     84c:	3f 90       	pop	r3
     84e:	2f 90       	pop	r2
     850:	1f 90       	pop	r1
     852:	0f 90       	pop	r0
     854:	0f be       	out	0x3f, r0	; 63
     856:	0f 90       	pop	r0

	asm volatile ( "ret" );
     858:	08 95       	ret

0000085a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     85a:	0f 92       	push	r0
     85c:	0f b6       	in	r0, 0x3f	; 63
     85e:	f8 94       	cli
     860:	0f 92       	push	r0
     862:	1f 92       	push	r1
     864:	11 24       	eor	r1, r1
     866:	2f 92       	push	r2
     868:	3f 92       	push	r3
     86a:	4f 92       	push	r4
     86c:	5f 92       	push	r5
     86e:	6f 92       	push	r6
     870:	7f 92       	push	r7
     872:	8f 92       	push	r8
     874:	9f 92       	push	r9
     876:	af 92       	push	r10
     878:	bf 92       	push	r11
     87a:	cf 92       	push	r12
     87c:	df 92       	push	r13
     87e:	ef 92       	push	r14
     880:	ff 92       	push	r15
     882:	0f 93       	push	r16
     884:	1f 93       	push	r17
     886:	2f 93       	push	r18
     888:	3f 93       	push	r19
     88a:	4f 93       	push	r20
     88c:	5f 93       	push	r21
     88e:	6f 93       	push	r22
     890:	7f 93       	push	r23
     892:	8f 93       	push	r24
     894:	9f 93       	push	r25
     896:	af 93       	push	r26
     898:	bf 93       	push	r27
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	ef 93       	push	r30
     8a0:	ff 93       	push	r31
     8a2:	a0 91 5c 07 	lds	r26, 0x075C	; 0x80075c <pxCurrentTCB>
     8a6:	b0 91 5d 07 	lds	r27, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     8aa:	0d b6       	in	r0, 0x3d	; 61
     8ac:	0d 92       	st	X+, r0
     8ae:	0e b6       	in	r0, 0x3e	; 62
     8b0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     8b2:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vTaskIncrementTick>
	vTaskSwitchContext();
     8b6:	0e 94 96 07 	call	0xf2c	; 0xf2c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     8ba:	a0 91 5c 07 	lds	r26, 0x075C	; 0x80075c <pxCurrentTCB>
     8be:	b0 91 5d 07 	lds	r27, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     8c2:	cd 91       	ld	r28, X+
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	dd 91       	ld	r29, X+
     8c8:	de bf       	out	0x3e, r29	; 62
     8ca:	ff 91       	pop	r31
     8cc:	ef 91       	pop	r30
     8ce:	df 91       	pop	r29
     8d0:	cf 91       	pop	r28
     8d2:	bf 91       	pop	r27
     8d4:	af 91       	pop	r26
     8d6:	9f 91       	pop	r25
     8d8:	8f 91       	pop	r24
     8da:	7f 91       	pop	r23
     8dc:	6f 91       	pop	r22
     8de:	5f 91       	pop	r21
     8e0:	4f 91       	pop	r20
     8e2:	3f 91       	pop	r19
     8e4:	2f 91       	pop	r18
     8e6:	1f 91       	pop	r17
     8e8:	0f 91       	pop	r16
     8ea:	ff 90       	pop	r15
     8ec:	ef 90       	pop	r14
     8ee:	df 90       	pop	r13
     8f0:	cf 90       	pop	r12
     8f2:	bf 90       	pop	r11
     8f4:	af 90       	pop	r10
     8f6:	9f 90       	pop	r9
     8f8:	8f 90       	pop	r8
     8fa:	7f 90       	pop	r7
     8fc:	6f 90       	pop	r6
     8fe:	5f 90       	pop	r5
     900:	4f 90       	pop	r4
     902:	3f 90       	pop	r3
     904:	2f 90       	pop	r2
     906:	1f 90       	pop	r1
     908:	0f 90       	pop	r0
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     90e:	08 95       	ret

00000910 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     910:	0e 94 2d 04 	call	0x85a	; 0x85a <vPortYieldFromTick>
		asm volatile ( "reti" );
     914:	18 95       	reti

00000916 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     916:	cf 93       	push	r28
     918:	df 93       	push	r29
     91a:	ec 01       	movw	r28, r24
     91c:	e0 91 5c 07 	lds	r30, 0x075C	; 0x80075c <pxCurrentTCB>
     920:	f0 91 5d 07 	lds	r31, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     924:	93 83       	std	Z+3, r25	; 0x03
     926:	82 83       	std	Z+2, r24	; 0x02
     928:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xTickCount>
     92c:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xTickCount+0x1>
     930:	c8 17       	cp	r28, r24
     932:	d9 07       	cpc	r29, r25
     934:	68 f4       	brcc	.+26     	; 0x950 <prvAddCurrentTaskToDelayedList+0x3a>
     936:	60 91 5c 07 	lds	r22, 0x075C	; 0x80075c <pxCurrentTCB>
     93a:	70 91 5d 07 	lds	r23, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     93e:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <pxOverflowDelayedTaskList>
     942:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <pxOverflowDelayedTaskList+0x1>
     946:	6e 5f       	subi	r22, 0xFE	; 254
     948:	7f 4f       	sbci	r23, 0xFF	; 255
     94a:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInsert>
     94e:	17 c0       	rjmp	.+46     	; 0x97e <prvAddCurrentTaskToDelayedList+0x68>
     950:	60 91 5c 07 	lds	r22, 0x075C	; 0x80075c <pxCurrentTCB>
     954:	70 91 5d 07 	lds	r23, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     958:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <pxDelayedTaskList>
     95c:	90 91 1c 07 	lds	r25, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     960:	6e 5f       	subi	r22, 0xFE	; 254
     962:	7f 4f       	sbci	r23, 0xFF	; 255
     964:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInsert>
     968:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <xNextTaskUnblockTime>
     96c:	90 91 f6 02 	lds	r25, 0x02F6	; 0x8002f6 <xNextTaskUnblockTime+0x1>
     970:	c8 17       	cp	r28, r24
     972:	d9 07       	cpc	r29, r25
     974:	20 f4       	brcc	.+8      	; 0x97e <prvAddCurrentTaskToDelayedList+0x68>
     976:	d0 93 f6 02 	sts	0x02F6, r29	; 0x8002f6 <xNextTaskUnblockTime+0x1>
     97a:	c0 93 f5 02 	sts	0x02F5, r28	; 0x8002f5 <xNextTaskUnblockTime>
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	08 95       	ret

00000984 <xTaskGenericCreate>:
     984:	4f 92       	push	r4
     986:	5f 92       	push	r5
     988:	6f 92       	push	r6
     98a:	7f 92       	push	r7
     98c:	8f 92       	push	r8
     98e:	9f 92       	push	r9
     990:	af 92       	push	r10
     992:	bf 92       	push	r11
     994:	cf 92       	push	r12
     996:	df 92       	push	r13
     998:	ef 92       	push	r14
     99a:	ff 92       	push	r15
     99c:	0f 93       	push	r16
     99e:	1f 93       	push	r17
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	5c 01       	movw	r10, r24
     9a6:	4b 01       	movw	r8, r22
     9a8:	ea 01       	movw	r28, r20
     9aa:	29 01       	movw	r4, r18
     9ac:	81 e2       	ldi	r24, 0x21	; 33
     9ae:	90 e0       	ldi	r25, 0x00	; 0
     9b0:	0e 94 93 01 	call	0x326	; 0x326 <pvPortMalloc>
     9b4:	3c 01       	movw	r6, r24
     9b6:	00 97       	sbiw	r24, 0x00	; 0
     9b8:	09 f4       	brne	.+2      	; 0x9bc <xTaskGenericCreate+0x38>
     9ba:	db c0       	rjmp	.+438    	; 0xb72 <xTaskGenericCreate+0x1ee>
     9bc:	c1 14       	cp	r12, r1
     9be:	d1 04       	cpc	r13, r1
     9c0:	09 f0       	breq	.+2      	; 0x9c4 <xTaskGenericCreate+0x40>
     9c2:	d2 c0       	rjmp	.+420    	; 0xb68 <xTaskGenericCreate+0x1e4>
     9c4:	ce 01       	movw	r24, r28
     9c6:	0e 94 93 01 	call	0x326	; 0x326 <pvPortMalloc>
     9ca:	f3 01       	movw	r30, r6
     9cc:	90 8f       	std	Z+24, r25	; 0x18
     9ce:	87 8b       	std	Z+23, r24	; 0x17
     9d0:	00 97       	sbiw	r24, 0x00	; 0
     9d2:	21 f4       	brne	.+8      	; 0x9dc <xTaskGenericCreate+0x58>
     9d4:	c3 01       	movw	r24, r6
     9d6:	0e 94 b9 01 	call	0x372	; 0x372 <vPortFree>
     9da:	cb c0       	rjmp	.+406    	; 0xb72 <xTaskGenericCreate+0x1ee>
     9dc:	ae 01       	movw	r20, r28
     9de:	65 ea       	ldi	r22, 0xA5	; 165
     9e0:	70 e0       	ldi	r23, 0x00	; 0
     9e2:	0e 94 24 08 	call	0x1048	; 0x1048 <memset>
     9e6:	21 97       	sbiw	r28, 0x01	; 1
     9e8:	f3 01       	movw	r30, r6
     9ea:	87 89       	ldd	r24, Z+23	; 0x17
     9ec:	90 8d       	ldd	r25, Z+24	; 0x18
     9ee:	c8 0f       	add	r28, r24
     9f0:	d9 1f       	adc	r29, r25
     9f2:	48 e0       	ldi	r20, 0x08	; 8
     9f4:	50 e0       	ldi	r21, 0x00	; 0
     9f6:	b4 01       	movw	r22, r8
     9f8:	c3 01       	movw	r24, r6
     9fa:	49 96       	adiw	r24, 0x19	; 25
     9fc:	0e 94 2b 08 	call	0x1056	; 0x1056 <strncpy>
     a00:	f3 01       	movw	r30, r6
     a02:	10 a2       	std	Z+32, r1	; 0x20
     a04:	10 2f       	mov	r17, r16
     a06:	05 30       	cpi	r16, 0x05	; 5
     a08:	08 f0       	brcs	.+2      	; 0xa0c <xTaskGenericCreate+0x88>
     a0a:	14 e0       	ldi	r17, 0x04	; 4
     a0c:	f3 01       	movw	r30, r6
     a0e:	16 8b       	std	Z+22, r17	; 0x16
     a10:	63 01       	movw	r12, r6
     a12:	f2 e0       	ldi	r31, 0x02	; 2
     a14:	cf 0e       	add	r12, r31
     a16:	d1 1c       	adc	r13, r1
     a18:	c6 01       	movw	r24, r12
     a1a:	0e 94 a7 02 	call	0x54e	; 0x54e <vListInitialiseItem>
     a1e:	c3 01       	movw	r24, r6
     a20:	0c 96       	adiw	r24, 0x0c	; 12
     a22:	0e 94 a7 02 	call	0x54e	; 0x54e <vListInitialiseItem>
     a26:	f3 01       	movw	r30, r6
     a28:	71 86       	std	Z+9, r7	; 0x09
     a2a:	60 86       	std	Z+8, r6	; 0x08
     a2c:	85 e0       	ldi	r24, 0x05	; 5
     a2e:	90 e0       	ldi	r25, 0x00	; 0
     a30:	81 1b       	sub	r24, r17
     a32:	91 09       	sbc	r25, r1
     a34:	95 87       	std	Z+13, r25	; 0x0d
     a36:	84 87       	std	Z+12, r24	; 0x0c
     a38:	73 8a       	std	Z+19, r7	; 0x13
     a3a:	62 8a       	std	Z+18, r6	; 0x12
     a3c:	a2 01       	movw	r20, r4
     a3e:	b5 01       	movw	r22, r10
     a40:	ce 01       	movw	r24, r28
     a42:	0e 94 33 03 	call	0x666	; 0x666 <pxPortInitialiseStack>
     a46:	f3 01       	movw	r30, r6
     a48:	91 83       	std	Z+1, r25	; 0x01
     a4a:	80 83       	st	Z, r24
     a4c:	e1 14       	cp	r14, r1
     a4e:	f1 04       	cpc	r15, r1
     a50:	19 f0       	breq	.+6      	; 0xa58 <xTaskGenericCreate+0xd4>
     a52:	f7 01       	movw	r30, r14
     a54:	71 82       	std	Z+1, r7	; 0x01
     a56:	60 82       	st	Z, r6
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	0f 92       	push	r0
     a5e:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     a62:	8f 5f       	subi	r24, 0xFF	; 255
     a64:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxCurrentNumberOfTasks>
     a68:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <pxCurrentTCB>
     a6c:	90 91 5d 07 	lds	r25, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     a70:	89 2b       	or	r24, r25
     a72:	a1 f5       	brne	.+104    	; 0xadc <xTaskGenericCreate+0x158>
     a74:	70 92 5d 07 	sts	0x075D, r7	; 0x80075d <pxCurrentTCB+0x1>
     a78:	60 92 5c 07 	sts	0x075C, r6	; 0x80075c <pxCurrentTCB>
     a7c:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     a80:	81 30       	cpi	r24, 0x01	; 1
     a82:	d9 f5       	brne	.+118    	; 0xafa <xTaskGenericCreate+0x176>
     a84:	cf e2       	ldi	r28, 0x2F	; 47
     a86:	d7 e0       	ldi	r29, 0x07	; 7
     a88:	0f 2e       	mov	r0, r31
     a8a:	fc e5       	ldi	r31, 0x5C	; 92
     a8c:	ef 2e       	mov	r14, r31
     a8e:	f7 e0       	ldi	r31, 0x07	; 7
     a90:	ff 2e       	mov	r15, r31
     a92:	f0 2d       	mov	r31, r0
     a94:	ce 01       	movw	r24, r28
     a96:	0e 94 99 02 	call	0x532	; 0x532 <vListInitialise>
     a9a:	29 96       	adiw	r28, 0x09	; 9
     a9c:	ce 15       	cp	r28, r14
     a9e:	df 05       	cpc	r29, r15
     aa0:	c9 f7       	brne	.-14     	; 0xa94 <xTaskGenericCreate+0x110>
     aa2:	86 e2       	ldi	r24, 0x26	; 38
     aa4:	97 e0       	ldi	r25, 0x07	; 7
     aa6:	0e 94 99 02 	call	0x532	; 0x532 <vListInitialise>
     aaa:	8d e1       	ldi	r24, 0x1D	; 29
     aac:	97 e0       	ldi	r25, 0x07	; 7
     aae:	0e 94 99 02 	call	0x532	; 0x532 <vListInitialise>
     ab2:	80 e1       	ldi	r24, 0x10	; 16
     ab4:	97 e0       	ldi	r25, 0x07	; 7
     ab6:	0e 94 99 02 	call	0x532	; 0x532 <vListInitialise>
     aba:	87 e0       	ldi	r24, 0x07	; 7
     abc:	97 e0       	ldi	r25, 0x07	; 7
     abe:	0e 94 99 02 	call	0x532	; 0x532 <vListInitialise>
     ac2:	86 e2       	ldi	r24, 0x26	; 38
     ac4:	97 e0       	ldi	r25, 0x07	; 7
     ac6:	90 93 1c 07 	sts	0x071C, r25	; 0x80071c <pxDelayedTaskList+0x1>
     aca:	80 93 1b 07 	sts	0x071B, r24	; 0x80071b <pxDelayedTaskList>
     ace:	8d e1       	ldi	r24, 0x1D	; 29
     ad0:	97 e0       	ldi	r25, 0x07	; 7
     ad2:	90 93 1a 07 	sts	0x071A, r25	; 0x80071a <pxOverflowDelayedTaskList+0x1>
     ad6:	80 93 19 07 	sts	0x0719, r24	; 0x800719 <pxOverflowDelayedTaskList>
     ada:	0f c0       	rjmp	.+30     	; 0xafa <xTaskGenericCreate+0x176>
     adc:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <xSchedulerRunning>
     ae0:	81 11       	cpse	r24, r1
     ae2:	0b c0       	rjmp	.+22     	; 0xafa <xTaskGenericCreate+0x176>
     ae4:	e0 91 5c 07 	lds	r30, 0x075C	; 0x80075c <pxCurrentTCB>
     ae8:	f0 91 5d 07 	lds	r31, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     aec:	86 89       	ldd	r24, Z+22	; 0x16
     aee:	08 17       	cp	r16, r24
     af0:	20 f0       	brcs	.+8      	; 0xafa <xTaskGenericCreate+0x176>
     af2:	70 92 5d 07 	sts	0x075D, r7	; 0x80075d <pxCurrentTCB+0x1>
     af6:	60 92 5c 07 	sts	0x075C, r6	; 0x80075c <pxCurrentTCB>
     afa:	f3 01       	movw	r30, r6
     afc:	86 89       	ldd	r24, Z+22	; 0x16
     afe:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTopUsedPriority>
     b02:	98 17       	cp	r25, r24
     b04:	10 f4       	brcc	.+4      	; 0xb0a <xTaskGenericCreate+0x186>
     b06:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxTopUsedPriority>
     b0a:	90 91 fb 06 	lds	r25, 0x06FB	; 0x8006fb <uxTaskNumber>
     b0e:	9f 5f       	subi	r25, 0xFF	; 255
     b10:	90 93 fb 06 	sts	0x06FB, r25	; 0x8006fb <uxTaskNumber>
     b14:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <uxTopReadyPriority>
     b18:	98 17       	cp	r25, r24
     b1a:	10 f4       	brcc	.+4      	; 0xb20 <xTaskGenericCreate+0x19c>
     b1c:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	9c 01       	movw	r18, r24
     b24:	22 0f       	add	r18, r18
     b26:	33 1f       	adc	r19, r19
     b28:	22 0f       	add	r18, r18
     b2a:	33 1f       	adc	r19, r19
     b2c:	22 0f       	add	r18, r18
     b2e:	33 1f       	adc	r19, r19
     b30:	82 0f       	add	r24, r18
     b32:	93 1f       	adc	r25, r19
     b34:	b6 01       	movw	r22, r12
     b36:	81 5d       	subi	r24, 0xD1	; 209
     b38:	98 4f       	sbci	r25, 0xF8	; 248
     b3a:	0e 94 ab 02 	call	0x556	; 0x556 <vListInsertEnd>
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63
     b42:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <xSchedulerRunning>
     b46:	88 23       	and	r24, r24
     b48:	59 f0       	breq	.+22     	; 0xb60 <xTaskGenericCreate+0x1dc>
     b4a:	e0 91 5c 07 	lds	r30, 0x075C	; 0x80075c <pxCurrentTCB>
     b4e:	f0 91 5d 07 	lds	r31, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     b52:	86 89       	ldd	r24, Z+22	; 0x16
     b54:	80 17       	cp	r24, r16
     b56:	30 f4       	brcc	.+12     	; 0xb64 <xTaskGenericCreate+0x1e0>
     b58:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortYield>
     b5c:	81 e0       	ldi	r24, 0x01	; 1
     b5e:	0a c0       	rjmp	.+20     	; 0xb74 <xTaskGenericCreate+0x1f0>
     b60:	81 e0       	ldi	r24, 0x01	; 1
     b62:	08 c0       	rjmp	.+16     	; 0xb74 <xTaskGenericCreate+0x1f0>
     b64:	81 e0       	ldi	r24, 0x01	; 1
     b66:	06 c0       	rjmp	.+12     	; 0xb74 <xTaskGenericCreate+0x1f0>
     b68:	fc 01       	movw	r30, r24
     b6a:	d0 8e       	std	Z+24, r13	; 0x18
     b6c:	c7 8a       	std	Z+23, r12	; 0x17
     b6e:	c6 01       	movw	r24, r12
     b70:	35 cf       	rjmp	.-406    	; 0x9dc <xTaskGenericCreate+0x58>
     b72:	8f ef       	ldi	r24, 0xFF	; 255
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	ff 90       	pop	r15
     b7e:	ef 90       	pop	r14
     b80:	df 90       	pop	r13
     b82:	cf 90       	pop	r12
     b84:	bf 90       	pop	r11
     b86:	af 90       	pop	r10
     b88:	9f 90       	pop	r9
     b8a:	8f 90       	pop	r8
     b8c:	7f 90       	pop	r7
     b8e:	6f 90       	pop	r6
     b90:	5f 90       	pop	r5
     b92:	4f 90       	pop	r4
     b94:	08 95       	ret

00000b96 <vTaskStartScheduler>:
     b96:	af 92       	push	r10
     b98:	bf 92       	push	r11
     b9a:	cf 92       	push	r12
     b9c:	df 92       	push	r13
     b9e:	ef 92       	push	r14
     ba0:	ff 92       	push	r15
     ba2:	0f 93       	push	r16
     ba4:	a1 2c       	mov	r10, r1
     ba6:	b1 2c       	mov	r11, r1
     ba8:	c1 2c       	mov	r12, r1
     baa:	d1 2c       	mov	r13, r1
     bac:	e1 2c       	mov	r14, r1
     bae:	f1 2c       	mov	r15, r1
     bb0:	00 e0       	ldi	r16, 0x00	; 0
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	30 e0       	ldi	r19, 0x00	; 0
     bb6:	45 e5       	ldi	r20, 0x55	; 85
     bb8:	50 e0       	ldi	r21, 0x00	; 0
     bba:	67 e0       	ldi	r22, 0x07	; 7
     bbc:	73 e0       	ldi	r23, 0x03	; 3
     bbe:	86 e6       	ldi	r24, 0x66	; 102
     bc0:	97 e0       	ldi	r25, 0x07	; 7
     bc2:	0e 94 c2 04 	call	0x984	; 0x984 <xTaskGenericCreate>
     bc6:	81 30       	cpi	r24, 0x01	; 1
     bc8:	49 f4       	brne	.+18     	; 0xbdc <vTaskStartScheduler+0x46>
     bca:	f8 94       	cli
     bcc:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <xSchedulerRunning>
     bd0:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <xTickCount+0x1>
     bd4:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <xTickCount>
     bd8:	0e 94 9f 03 	call	0x73e	; 0x73e <xPortStartScheduler>
     bdc:	0f 91       	pop	r16
     bde:	ff 90       	pop	r15
     be0:	ef 90       	pop	r14
     be2:	df 90       	pop	r13
     be4:	cf 90       	pop	r12
     be6:	bf 90       	pop	r11
     be8:	af 90       	pop	r10
     bea:	08 95       	ret

00000bec <vTaskSuspendAll>:
     bec:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxSchedulerSuspended>
     bf0:	8f 5f       	subi	r24, 0xFF	; 255
     bf2:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <uxSchedulerSuspended>
     bf6:	08 95       	ret

00000bf8 <vTaskIncrementTick>:
     bf8:	0f 93       	push	r16
     bfa:	1f 93       	push	r17
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
     c00:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxSchedulerSuspended>
     c04:	81 11       	cpse	r24, r1
     c06:	b2 c0       	rjmp	.+356    	; 0xd6c <vTaskIncrementTick+0x174>
     c08:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xTickCount>
     c0c:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xTickCount+0x1>
     c10:	01 96       	adiw	r24, 0x01	; 1
     c12:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <xTickCount+0x1>
     c16:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <xTickCount>
     c1a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xTickCount>
     c1e:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xTickCount+0x1>
     c22:	89 2b       	or	r24, r25
     c24:	99 f5       	brne	.+102    	; 0xc8c <vTaskIncrementTick+0x94>
     c26:	80 91 1b 07 	lds	r24, 0x071B	; 0x80071b <pxDelayedTaskList>
     c2a:	90 91 1c 07 	lds	r25, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     c2e:	20 91 19 07 	lds	r18, 0x0719	; 0x800719 <pxOverflowDelayedTaskList>
     c32:	30 91 1a 07 	lds	r19, 0x071A	; 0x80071a <pxOverflowDelayedTaskList+0x1>
     c36:	30 93 1c 07 	sts	0x071C, r19	; 0x80071c <pxDelayedTaskList+0x1>
     c3a:	20 93 1b 07 	sts	0x071B, r18	; 0x80071b <pxDelayedTaskList>
     c3e:	90 93 1a 07 	sts	0x071A, r25	; 0x80071a <pxOverflowDelayedTaskList+0x1>
     c42:	80 93 19 07 	sts	0x0719, r24	; 0x800719 <pxOverflowDelayedTaskList>
     c46:	80 91 fc 06 	lds	r24, 0x06FC	; 0x8006fc <xNumOfOverflows>
     c4a:	8f 5f       	subi	r24, 0xFF	; 255
     c4c:	80 93 fc 06 	sts	0x06FC, r24	; 0x8006fc <xNumOfOverflows>
     c50:	e0 91 1b 07 	lds	r30, 0x071B	; 0x80071b <pxDelayedTaskList>
     c54:	f0 91 1c 07 	lds	r31, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     c58:	80 81       	ld	r24, Z
     c5a:	81 11       	cpse	r24, r1
     c5c:	07 c0       	rjmp	.+14     	; 0xc6c <vTaskIncrementTick+0x74>
     c5e:	8f ef       	ldi	r24, 0xFF	; 255
     c60:	9f ef       	ldi	r25, 0xFF	; 255
     c62:	90 93 f6 02 	sts	0x02F6, r25	; 0x8002f6 <xNextTaskUnblockTime+0x1>
     c66:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <xNextTaskUnblockTime>
     c6a:	10 c0       	rjmp	.+32     	; 0xc8c <vTaskIncrementTick+0x94>
     c6c:	e0 91 1b 07 	lds	r30, 0x071B	; 0x80071b <pxDelayedTaskList>
     c70:	f0 91 1c 07 	lds	r31, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     c74:	05 80       	ldd	r0, Z+5	; 0x05
     c76:	f6 81       	ldd	r31, Z+6	; 0x06
     c78:	e0 2d       	mov	r30, r0
     c7a:	06 80       	ldd	r0, Z+6	; 0x06
     c7c:	f7 81       	ldd	r31, Z+7	; 0x07
     c7e:	e0 2d       	mov	r30, r0
     c80:	82 81       	ldd	r24, Z+2	; 0x02
     c82:	93 81       	ldd	r25, Z+3	; 0x03
     c84:	90 93 f6 02 	sts	0x02F6, r25	; 0x8002f6 <xNextTaskUnblockTime+0x1>
     c88:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <xNextTaskUnblockTime>
     c8c:	20 91 03 07 	lds	r18, 0x0703	; 0x800703 <xTickCount>
     c90:	30 91 04 07 	lds	r19, 0x0704	; 0x800704 <xTickCount+0x1>
     c94:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <xNextTaskUnblockTime>
     c98:	90 91 f6 02 	lds	r25, 0x02F6	; 0x8002f6 <xNextTaskUnblockTime+0x1>
     c9c:	28 17       	cp	r18, r24
     c9e:	39 07       	cpc	r19, r25
     ca0:	08 f4       	brcc	.+2      	; 0xca4 <vTaskIncrementTick+0xac>
     ca2:	69 c0       	rjmp	.+210    	; 0xd76 <vTaskIncrementTick+0x17e>
     ca4:	e0 91 1b 07 	lds	r30, 0x071B	; 0x80071b <pxDelayedTaskList>
     ca8:	f0 91 1c 07 	lds	r31, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     cac:	80 81       	ld	r24, Z
     cae:	88 23       	and	r24, r24
     cb0:	99 f0       	breq	.+38     	; 0xcd8 <vTaskIncrementTick+0xe0>
     cb2:	e0 91 1b 07 	lds	r30, 0x071B	; 0x80071b <pxDelayedTaskList>
     cb6:	f0 91 1c 07 	lds	r31, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     cba:	05 80       	ldd	r0, Z+5	; 0x05
     cbc:	f6 81       	ldd	r31, Z+6	; 0x06
     cbe:	e0 2d       	mov	r30, r0
     cc0:	c6 81       	ldd	r28, Z+6	; 0x06
     cc2:	d7 81       	ldd	r29, Z+7	; 0x07
     cc4:	8a 81       	ldd	r24, Y+2	; 0x02
     cc6:	9b 81       	ldd	r25, Y+3	; 0x03
     cc8:	20 91 03 07 	lds	r18, 0x0703	; 0x800703 <xTickCount>
     ccc:	30 91 04 07 	lds	r19, 0x0704	; 0x800704 <xTickCount+0x1>
     cd0:	28 17       	cp	r18, r24
     cd2:	39 07       	cpc	r19, r25
     cd4:	f8 f4       	brcc	.+62     	; 0xd14 <vTaskIncrementTick+0x11c>
     cd6:	19 c0       	rjmp	.+50     	; 0xd0a <vTaskIncrementTick+0x112>
     cd8:	8f ef       	ldi	r24, 0xFF	; 255
     cda:	9f ef       	ldi	r25, 0xFF	; 255
     cdc:	90 93 f6 02 	sts	0x02F6, r25	; 0x8002f6 <xNextTaskUnblockTime+0x1>
     ce0:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <xNextTaskUnblockTime>
     ce4:	48 c0       	rjmp	.+144    	; 0xd76 <vTaskIncrementTick+0x17e>
     ce6:	e0 91 1b 07 	lds	r30, 0x071B	; 0x80071b <pxDelayedTaskList>
     cea:	f0 91 1c 07 	lds	r31, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     cee:	05 80       	ldd	r0, Z+5	; 0x05
     cf0:	f6 81       	ldd	r31, Z+6	; 0x06
     cf2:	e0 2d       	mov	r30, r0
     cf4:	c6 81       	ldd	r28, Z+6	; 0x06
     cf6:	d7 81       	ldd	r29, Z+7	; 0x07
     cf8:	8a 81       	ldd	r24, Y+2	; 0x02
     cfa:	9b 81       	ldd	r25, Y+3	; 0x03
     cfc:	20 91 03 07 	lds	r18, 0x0703	; 0x800703 <xTickCount>
     d00:	30 91 04 07 	lds	r19, 0x0704	; 0x800704 <xTickCount+0x1>
     d04:	28 17       	cp	r18, r24
     d06:	39 07       	cpc	r19, r25
     d08:	28 f4       	brcc	.+10     	; 0xd14 <vTaskIncrementTick+0x11c>
     d0a:	90 93 f6 02 	sts	0x02F6, r25	; 0x8002f6 <xNextTaskUnblockTime+0x1>
     d0e:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <xNextTaskUnblockTime>
     d12:	31 c0       	rjmp	.+98     	; 0xd76 <vTaskIncrementTick+0x17e>
     d14:	8e 01       	movw	r16, r28
     d16:	0e 5f       	subi	r16, 0xFE	; 254
     d18:	1f 4f       	sbci	r17, 0xFF	; 255
     d1a:	c8 01       	movw	r24, r16
     d1c:	0e 94 0d 03 	call	0x61a	; 0x61a <vListRemove>
     d20:	8c 89       	ldd	r24, Y+20	; 0x14
     d22:	9d 89       	ldd	r25, Y+21	; 0x15
     d24:	89 2b       	or	r24, r25
     d26:	21 f0       	breq	.+8      	; 0xd30 <vTaskIncrementTick+0x138>
     d28:	ce 01       	movw	r24, r28
     d2a:	0c 96       	adiw	r24, 0x0c	; 12
     d2c:	0e 94 0d 03 	call	0x61a	; 0x61a <vListRemove>
     d30:	8e 89       	ldd	r24, Y+22	; 0x16
     d32:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <uxTopReadyPriority>
     d36:	98 17       	cp	r25, r24
     d38:	10 f4       	brcc	.+4      	; 0xd3e <vTaskIncrementTick+0x146>
     d3a:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
     d3e:	90 e0       	ldi	r25, 0x00	; 0
     d40:	9c 01       	movw	r18, r24
     d42:	22 0f       	add	r18, r18
     d44:	33 1f       	adc	r19, r19
     d46:	22 0f       	add	r18, r18
     d48:	33 1f       	adc	r19, r19
     d4a:	22 0f       	add	r18, r18
     d4c:	33 1f       	adc	r19, r19
     d4e:	82 0f       	add	r24, r18
     d50:	93 1f       	adc	r25, r19
     d52:	b8 01       	movw	r22, r16
     d54:	81 5d       	subi	r24, 0xD1	; 209
     d56:	98 4f       	sbci	r25, 0xF8	; 248
     d58:	0e 94 ab 02 	call	0x556	; 0x556 <vListInsertEnd>
     d5c:	e0 91 1b 07 	lds	r30, 0x071B	; 0x80071b <pxDelayedTaskList>
     d60:	f0 91 1c 07 	lds	r31, 0x071C	; 0x80071c <pxDelayedTaskList+0x1>
     d64:	80 81       	ld	r24, Z
     d66:	81 11       	cpse	r24, r1
     d68:	be cf       	rjmp	.-132    	; 0xce6 <vTaskIncrementTick+0xee>
     d6a:	b6 cf       	rjmp	.-148    	; 0xcd8 <vTaskIncrementTick+0xe0>
     d6c:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxMissedTicks>
     d70:	8f 5f       	subi	r24, 0xFF	; 255
     d72:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <uxMissedTicks>
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	1f 91       	pop	r17
     d7c:	0f 91       	pop	r16
     d7e:	08 95       	ret

00000d80 <xTaskResumeAll>:
     d80:	cf 92       	push	r12
     d82:	df 92       	push	r13
     d84:	ef 92       	push	r14
     d86:	ff 92       	push	r15
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	0f b6       	in	r0, 0x3f	; 63
     d92:	f8 94       	cli
     d94:	0f 92       	push	r0
     d96:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxSchedulerSuspended>
     d9a:	81 50       	subi	r24, 0x01	; 1
     d9c:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <uxSchedulerSuspended>
     da0:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxSchedulerSuspended>
     da4:	81 11       	cpse	r24, r1
     da6:	64 c0       	rjmp	.+200    	; 0xe70 <xTaskResumeAll+0xf0>
     da8:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     dac:	81 11       	cpse	r24, r1
     dae:	32 c0       	rjmp	.+100    	; 0xe14 <xTaskResumeAll+0x94>
     db0:	62 c0       	rjmp	.+196    	; 0xe76 <xTaskResumeAll+0xf6>
     db2:	d7 01       	movw	r26, r14
     db4:	15 96       	adiw	r26, 0x05	; 5
     db6:	ed 91       	ld	r30, X+
     db8:	fc 91       	ld	r31, X
     dba:	16 97       	sbiw	r26, 0x06	; 6
     dbc:	c6 81       	ldd	r28, Z+6	; 0x06
     dbe:	d7 81       	ldd	r29, Z+7	; 0x07
     dc0:	ce 01       	movw	r24, r28
     dc2:	0c 96       	adiw	r24, 0x0c	; 12
     dc4:	0e 94 0d 03 	call	0x61a	; 0x61a <vListRemove>
     dc8:	8e 01       	movw	r16, r28
     dca:	0e 5f       	subi	r16, 0xFE	; 254
     dcc:	1f 4f       	sbci	r17, 0xFF	; 255
     dce:	c8 01       	movw	r24, r16
     dd0:	0e 94 0d 03 	call	0x61a	; 0x61a <vListRemove>
     dd4:	8e 89       	ldd	r24, Y+22	; 0x16
     dd6:	90 91 01 07 	lds	r25, 0x0701	; 0x800701 <uxTopReadyPriority>
     dda:	98 17       	cp	r25, r24
     ddc:	10 f4       	brcc	.+4      	; 0xde2 <xTaskResumeAll+0x62>
     dde:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
     de2:	90 e0       	ldi	r25, 0x00	; 0
     de4:	9c 01       	movw	r18, r24
     de6:	22 0f       	add	r18, r18
     de8:	33 1f       	adc	r19, r19
     dea:	22 0f       	add	r18, r18
     dec:	33 1f       	adc	r19, r19
     dee:	22 0f       	add	r18, r18
     df0:	33 1f       	adc	r19, r19
     df2:	82 0f       	add	r24, r18
     df4:	93 1f       	adc	r25, r19
     df6:	b8 01       	movw	r22, r16
     df8:	81 5d       	subi	r24, 0xD1	; 209
     dfa:	98 4f       	sbci	r25, 0xF8	; 248
     dfc:	0e 94 ab 02 	call	0x556	; 0x556 <vListInsertEnd>
     e00:	e0 91 5c 07 	lds	r30, 0x075C	; 0x80075c <pxCurrentTCB>
     e04:	f0 91 5d 07 	lds	r31, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     e08:	9e 89       	ldd	r25, Y+22	; 0x16
     e0a:	86 89       	ldd	r24, Z+22	; 0x16
     e0c:	98 17       	cp	r25, r24
     e0e:	58 f0       	brcs	.+22     	; 0xe26 <xTaskResumeAll+0xa6>
     e10:	dc 2c       	mov	r13, r12
     e12:	09 c0       	rjmp	.+18     	; 0xe26 <xTaskResumeAll+0xa6>
     e14:	d1 2c       	mov	r13, r1
     e16:	0f 2e       	mov	r0, r31
     e18:	f0 e1       	ldi	r31, 0x10	; 16
     e1a:	ef 2e       	mov	r14, r31
     e1c:	f7 e0       	ldi	r31, 0x07	; 7
     e1e:	ff 2e       	mov	r15, r31
     e20:	f0 2d       	mov	r31, r0
     e22:	cc 24       	eor	r12, r12
     e24:	c3 94       	inc	r12
     e26:	f7 01       	movw	r30, r14
     e28:	80 81       	ld	r24, Z
     e2a:	81 11       	cpse	r24, r1
     e2c:	c2 cf       	rjmp	.-124    	; 0xdb2 <xTaskResumeAll+0x32>
     e2e:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxMissedTicks>
     e32:	88 23       	and	r24, r24
     e34:	81 f0       	breq	.+32     	; 0xe56 <xTaskResumeAll+0xd6>
     e36:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxMissedTicks>
     e3a:	88 23       	and	r24, r24
     e3c:	99 f0       	breq	.+38     	; 0xe64 <xTaskResumeAll+0xe4>
     e3e:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vTaskIncrementTick>
     e42:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxMissedTicks>
     e46:	81 50       	subi	r24, 0x01	; 1
     e48:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <uxMissedTicks>
     e4c:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <uxMissedTicks>
     e50:	81 11       	cpse	r24, r1
     e52:	f5 cf       	rjmp	.-22     	; 0xe3e <xTaskResumeAll+0xbe>
     e54:	07 c0       	rjmp	.+14     	; 0xe64 <xTaskResumeAll+0xe4>
     e56:	f1 e0       	ldi	r31, 0x01	; 1
     e58:	df 16       	cp	r13, r31
     e5a:	21 f0       	breq	.+8      	; 0xe64 <xTaskResumeAll+0xe4>
     e5c:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <xMissedYield>
     e60:	81 30       	cpi	r24, 0x01	; 1
     e62:	41 f4       	brne	.+16     	; 0xe74 <xTaskResumeAll+0xf4>
     e64:	10 92 fd 06 	sts	0x06FD, r1	; 0x8006fd <xMissedYield>
     e68:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortYield>
     e6c:	81 e0       	ldi	r24, 0x01	; 1
     e6e:	03 c0       	rjmp	.+6      	; 0xe76 <xTaskResumeAll+0xf6>
     e70:	80 e0       	ldi	r24, 0x00	; 0
     e72:	01 c0       	rjmp	.+2      	; 0xe76 <xTaskResumeAll+0xf6>
     e74:	80 e0       	ldi	r24, 0x00	; 0
     e76:	0f 90       	pop	r0
     e78:	0f be       	out	0x3f, r0	; 63
     e7a:	df 91       	pop	r29
     e7c:	cf 91       	pop	r28
     e7e:	1f 91       	pop	r17
     e80:	0f 91       	pop	r16
     e82:	ff 90       	pop	r15
     e84:	ef 90       	pop	r14
     e86:	df 90       	pop	r13
     e88:	cf 90       	pop	r12
     e8a:	08 95       	ret

00000e8c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     e8c:	cf 93       	push	r28
     e8e:	df 93       	push	r29
     e90:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     e92:	89 2b       	or	r24, r25
     e94:	b1 f0       	breq	.+44     	; 0xec2 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
     e96:	0e 94 f6 05 	call	0xbec	; 0xbec <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     e9a:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xTickCount>
     e9e:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xTickCount+0x1>
     ea2:	c8 0f       	add	r28, r24
     ea4:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     ea6:	80 91 5c 07 	lds	r24, 0x075C	; 0x80075c <pxCurrentTCB>
     eaa:	90 91 5d 07 	lds	r25, 0x075D	; 0x80075d <pxCurrentTCB+0x1>
     eae:	02 96       	adiw	r24, 0x02	; 2
     eb0:	0e 94 0d 03 	call	0x61a	; 0x61a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     eb4:	ce 01       	movw	r24, r28
     eb6:	0e 94 8b 04 	call	0x916	; 0x916 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     eba:	0e 94 c0 06 	call	0xd80	; 0xd80 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     ebe:	81 11       	cpse	r24, r1
     ec0:	02 c0       	rjmp	.+4      	; 0xec6 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
     ec2:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortYield>
		}
	}
     ec6:	df 91       	pop	r29
     ec8:	cf 91       	pop	r28
     eca:	08 95       	ret

00000ecc <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     ecc:	07 e0       	ldi	r16, 0x07	; 7
     ece:	17 e0       	ldi	r17, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
     ed0:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxTasksDeleted>
     ed4:	88 23       	and	r24, r24
     ed6:	e1 f3       	breq	.-8      	; 0xed0 <prvIdleTask+0x4>
		{
			vTaskSuspendAll();
     ed8:	0e 94 f6 05 	call	0xbec	; 0xbec <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     edc:	d8 01       	movw	r26, r16
     ede:	cc 91       	ld	r28, X
			xTaskResumeAll();
     ee0:	0e 94 c0 06 	call	0xd80	; 0xd80 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     ee4:	cc 23       	and	r28, r28
     ee6:	a1 f3       	breq	.-24     	; 0xed0 <prvIdleTask+0x4>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
     ee8:	0f b6       	in	r0, 0x3f	; 63
     eea:	f8 94       	cli
     eec:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
     eee:	d8 01       	movw	r26, r16
     ef0:	15 96       	adiw	r26, 0x05	; 5
     ef2:	ed 91       	ld	r30, X+
     ef4:	fc 91       	ld	r31, X
     ef6:	16 97       	sbiw	r26, 0x06	; 6
     ef8:	c6 81       	ldd	r28, Z+6	; 0x06
     efa:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
     efc:	ce 01       	movw	r24, r28
     efe:	02 96       	adiw	r24, 0x02	; 2
     f00:	0e 94 0d 03 	call	0x61a	; 0x61a <vListRemove>
					--uxCurrentNumberOfTasks;
     f04:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     f08:	81 50       	subi	r24, 0x01	; 1
     f0a:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
     f0e:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <uxTasksDeleted>
     f12:	81 50       	subi	r24, 0x01	; 1
     f14:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
     f18:	0f 90       	pop	r0
     f1a:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
     f1c:	8f 89       	ldd	r24, Y+23	; 0x17
     f1e:	98 8d       	ldd	r25, Y+24	; 0x18
     f20:	0e 94 b9 01 	call	0x372	; 0x372 <vPortFree>
		vPortFree( pxTCB );
     f24:	ce 01       	movw	r24, r28
     f26:	0e 94 b9 01 	call	0x372	; 0x372 <vPortFree>
     f2a:	d2 cf       	rjmp	.-92     	; 0xed0 <prvIdleTask+0x4>

00000f2c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     f2c:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <uxSchedulerSuspended>
     f30:	81 11       	cpse	r24, r1
     f32:	13 c0       	rjmp	.+38     	; 0xf5a <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
     f34:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
     f38:	90 e0       	ldi	r25, 0x00	; 0
     f3a:	fc 01       	movw	r30, r24
     f3c:	ee 0f       	add	r30, r30
     f3e:	ff 1f       	adc	r31, r31
     f40:	ee 0f       	add	r30, r30
     f42:	ff 1f       	adc	r31, r31
     f44:	ee 0f       	add	r30, r30
     f46:	ff 1f       	adc	r31, r31
     f48:	8e 0f       	add	r24, r30
     f4a:	9f 1f       	adc	r25, r31
     f4c:	fc 01       	movw	r30, r24
     f4e:	e1 5d       	subi	r30, 0xD1	; 209
     f50:	f8 4f       	sbci	r31, 0xF8	; 248
     f52:	80 81       	ld	r24, Z
     f54:	88 23       	and	r24, r24
     f56:	29 f0       	breq	.+10     	; 0xf62 <vTaskSwitchContext+0x36>
     f58:	1b c0       	rjmp	.+54     	; 0xf90 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     f5a:	81 e0       	ldi	r24, 0x01	; 1
     f5c:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <xMissedYield>
     f60:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
     f62:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
     f66:	81 50       	subi	r24, 0x01	; 1
     f68:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
     f6c:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
     f70:	90 e0       	ldi	r25, 0x00	; 0
     f72:	fc 01       	movw	r30, r24
     f74:	ee 0f       	add	r30, r30
     f76:	ff 1f       	adc	r31, r31
     f78:	ee 0f       	add	r30, r30
     f7a:	ff 1f       	adc	r31, r31
     f7c:	ee 0f       	add	r30, r30
     f7e:	ff 1f       	adc	r31, r31
     f80:	8e 0f       	add	r24, r30
     f82:	9f 1f       	adc	r25, r31
     f84:	fc 01       	movw	r30, r24
     f86:	e1 5d       	subi	r30, 0xD1	; 209
     f88:	f8 4f       	sbci	r31, 0xF8	; 248
     f8a:	80 81       	ld	r24, Z
     f8c:	88 23       	and	r24, r24
     f8e:	49 f3       	breq	.-46     	; 0xf62 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
     f90:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <uxTopReadyPriority>
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	9c 01       	movw	r18, r24
     f98:	22 0f       	add	r18, r18
     f9a:	33 1f       	adc	r19, r19
     f9c:	22 0f       	add	r18, r18
     f9e:	33 1f       	adc	r19, r19
     fa0:	22 0f       	add	r18, r18
     fa2:	33 1f       	adc	r19, r19
     fa4:	28 0f       	add	r18, r24
     fa6:	39 1f       	adc	r19, r25
     fa8:	d9 01       	movw	r26, r18
     faa:	a1 5d       	subi	r26, 0xD1	; 209
     fac:	b8 4f       	sbci	r27, 0xF8	; 248
     fae:	11 96       	adiw	r26, 0x01	; 1
     fb0:	ed 91       	ld	r30, X+
     fb2:	fc 91       	ld	r31, X
     fb4:	12 97       	sbiw	r26, 0x02	; 2
     fb6:	02 80       	ldd	r0, Z+2	; 0x02
     fb8:	f3 81       	ldd	r31, Z+3	; 0x03
     fba:	e0 2d       	mov	r30, r0
     fbc:	12 96       	adiw	r26, 0x02	; 2
     fbe:	fc 93       	st	X, r31
     fc0:	ee 93       	st	-X, r30
     fc2:	11 97       	sbiw	r26, 0x01	; 1
     fc4:	2e 5c       	subi	r18, 0xCE	; 206
     fc6:	38 4f       	sbci	r19, 0xF8	; 248
     fc8:	e2 17       	cp	r30, r18
     fca:	f3 07       	cpc	r31, r19
     fcc:	29 f4       	brne	.+10     	; 0xfd8 <vTaskSwitchContext+0xac>
     fce:	22 81       	ldd	r18, Z+2	; 0x02
     fd0:	33 81       	ldd	r19, Z+3	; 0x03
     fd2:	fd 01       	movw	r30, r26
     fd4:	32 83       	std	Z+2, r19	; 0x02
     fd6:	21 83       	std	Z+1, r18	; 0x01
     fd8:	fc 01       	movw	r30, r24
     fda:	ee 0f       	add	r30, r30
     fdc:	ff 1f       	adc	r31, r31
     fde:	ee 0f       	add	r30, r30
     fe0:	ff 1f       	adc	r31, r31
     fe2:	ee 0f       	add	r30, r30
     fe4:	ff 1f       	adc	r31, r31
     fe6:	8e 0f       	add	r24, r30
     fe8:	9f 1f       	adc	r25, r31
     fea:	fc 01       	movw	r30, r24
     fec:	e1 5d       	subi	r30, 0xD1	; 209
     fee:	f8 4f       	sbci	r31, 0xF8	; 248
     ff0:	01 80       	ldd	r0, Z+1	; 0x01
     ff2:	f2 81       	ldd	r31, Z+2	; 0x02
     ff4:	e0 2d       	mov	r30, r0
     ff6:	86 81       	ldd	r24, Z+6	; 0x06
     ff8:	97 81       	ldd	r25, Z+7	; 0x07
     ffa:	90 93 5d 07 	sts	0x075D, r25	; 0x80075d <pxCurrentTCB+0x1>
     ffe:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <pxCurrentTCB>
    1002:	08 95       	ret

00001004 <main>:



int main(void)
{	
	LED_vidInit();
    1004:	0e 94 2a 02 	call	0x454	; 0x454 <LED_vidInit>
	KPD_vidInit();
    1008:	0e 94 ed 01 	call	0x3da	; 0x3da <KPD_vidInit>
	/*Create an Rtos Task*/
	xTaskCreate(KPD_GetPressedKey, NULL, 250, NULL, 3, NULL);
    100c:	a1 2c       	mov	r10, r1
    100e:	b1 2c       	mov	r11, r1
    1010:	c1 2c       	mov	r12, r1
    1012:	d1 2c       	mov	r13, r1
    1014:	e1 2c       	mov	r14, r1
    1016:	f1 2c       	mov	r15, r1
    1018:	03 e0       	ldi	r16, 0x03	; 3
    101a:	20 e0       	ldi	r18, 0x00	; 0
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	4a ef       	ldi	r20, 0xFA	; 250
    1020:	50 e0       	ldi	r21, 0x00	; 0
    1022:	60 e0       	ldi	r22, 0x00	; 0
    1024:	70 e0       	ldi	r23, 0x00	; 0
    1026:	8a eb       	ldi	r24, 0xBA	; 186
    1028:	91 e0       	ldi	r25, 0x01	; 1
    102a:	0e 94 c2 04 	call	0x984	; 0x984 <xTaskGenericCreate>
	xTaskCreate(LED_vidActivatePattern, NULL, 250, NULL, 3, NULL);
    102e:	20 e0       	ldi	r18, 0x00	; 0
    1030:	30 e0       	ldi	r19, 0x00	; 0
    1032:	4a ef       	ldi	r20, 0xFA	; 250
    1034:	50 e0       	ldi	r21, 0x00	; 0
    1036:	60 e0       	ldi	r22, 0x00	; 0
    1038:	70 e0       	ldi	r23, 0x00	; 0
    103a:	8f e2       	ldi	r24, 0x2F	; 47
    103c:	92 e0       	ldi	r25, 0x02	; 2
    103e:	0e 94 c2 04 	call	0x984	; 0x984 <xTaskGenericCreate>
	
	/*Start Rtos*/
	vTaskStartScheduler();
    1042:	0e 94 cb 05 	call	0xb96	; 0xb96 <vTaskStartScheduler>
    1046:	ff cf       	rjmp	.-2      	; 0x1046 <main+0x42>

00001048 <memset>:
    1048:	dc 01       	movw	r26, r24
    104a:	01 c0       	rjmp	.+2      	; 0x104e <memset+0x6>
    104c:	6d 93       	st	X+, r22
    104e:	41 50       	subi	r20, 0x01	; 1
    1050:	50 40       	sbci	r21, 0x00	; 0
    1052:	e0 f7       	brcc	.-8      	; 0x104c <memset+0x4>
    1054:	08 95       	ret

00001056 <strncpy>:
    1056:	fb 01       	movw	r30, r22
    1058:	dc 01       	movw	r26, r24
    105a:	41 50       	subi	r20, 0x01	; 1
    105c:	50 40       	sbci	r21, 0x00	; 0
    105e:	48 f0       	brcs	.+18     	; 0x1072 <strncpy+0x1c>
    1060:	01 90       	ld	r0, Z+
    1062:	0d 92       	st	X+, r0
    1064:	00 20       	and	r0, r0
    1066:	c9 f7       	brne	.-14     	; 0x105a <strncpy+0x4>
    1068:	01 c0       	rjmp	.+2      	; 0x106c <strncpy+0x16>
    106a:	1d 92       	st	X+, r1
    106c:	41 50       	subi	r20, 0x01	; 1
    106e:	50 40       	sbci	r21, 0x00	; 0
    1070:	e0 f7       	brcc	.-8      	; 0x106a <strncpy+0x14>
    1072:	08 95       	ret

00001074 <_exit>:
    1074:	f8 94       	cli

00001076 <__stop_program>:
    1076:	ff cf       	rjmp	.-2      	; 0x1076 <__stop_program>
